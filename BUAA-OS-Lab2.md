# Lab2

## 一、指导书学习笔记

### 1、MIPS 4Kc的地址映射

在4Kc 上，软件访存的虚拟地址会先被MMU 硬件映射到物理地址，随后使用物理地址来访问内存或其他外设。与本实验相关的映射与寻址规则（内存布局）如下：

* 若虚拟地址处于 `0x80000000~0x9fffffff` (kseg0)，则将虚拟地址的最高位置0 得到物理地址，通过cache 访存。这一部分用于存放内核代码与数据。
* 若虚拟地址处于 `0xa0000000~0xbfffffff` (kseg1)，则将虚拟地址的最高3位置0 得到物理地址，不通过cache 访存。这一部分可以用于访问外设。
* 若虚拟地址处于 `0x00000000~0x7fffffff` (kuseg)，则需要通过TLB 转换成物理地址，再通过cache 访存。这一部分用于存放用户程序代码与数据。

以上的 **“将虚拟地址最高%位置0"** 指的是 **二进制下** 的地址，而非写出来的十六进制（这里我想了好久，才发现一直在疑惑的点实际是我一开始就想错了）

在4Kc 中，使用MMU 来完成上述地址映射，MMU 采用硬件TLB 来完成地址映射。TLB需要由软件进行填写，即操作系统内核负责维护TLB 中的数据。所有对低2GB 空间（kuseg）的内存访问操作都需要经过TLB。

### 2、初始化分配内存

在未建立内存管理机制的时候，需要手动分配内存。

根据映射规则，0x80400000 对应的物理地址是0x400000。在物理地址0x400000 的前面，存放着操作系统内核的代码和定义的全局变量或数组（还额外保留了一些空间）。接下来将从物理地址 0x400000 开始分配物理内存，用于建立管理内存的数据结构。

* 将`a`按`n`对齐

  ```
  #define ROUND(a, n) (((((u_long)(a)) + (n)-1)) & ~((n)-1))
  ```

### 3、链表宏

* `LIST_HEAD(name, type)`，创建一个名称为name 链表的头部结构体，包含一个指向type类型结构体的指针，这个指针可以指向链表的首个元素。
* `LIST_ENTRY(type)`，作为一个特殊的类型出现，例如可以进行如下的定义：

  ```
  LIST_ENTRY(Page) a;
  ```

  它的本质是一个链表项，包括指向下一个元素的指针le_next，以及指向前一个元素链表项le_next 的指针le_prev。le_prev 是一个指针的指针，它的作用是当删除一个元素时，更改前一个元素链表项的le_next。
* `LIST_EMPTY(head)`，判断head 指针指向的头部结构体对应的链表是否为空。
* `LIST_FIRST(head)`，将返回head 对应的链表的首个元素。
* `LIST_INIT(head)`，将head 对应的链表初始化。
* `LIST_NEXT(elm, field)`，返回指针elm 指向的元素在对应链表中的下一个元素的指针。`elm` 指针指向的结构体需要包含一个名为 `field` 的字段，类型是一个链表项 `LIST_ENTRY(type)`，下面出现的 `field` 含义均和此相同。
* `LIST_INSERT_AFTER(listelm, elm, field)`，将elm 插到已有元素listelm 之后。
* `LIST_INSERT_BEFORE(listelm, elm, field)`，将 `elm` 插到已有元素 `listelm` 之前。
* `LIST_INSERT_HEAD(head, elm, field)`，将`elm`插到`head` 对应链表的头部。
* `LIST_REMOVE(elm, field)`，将 `elm` 从对应链表中删除。

---

---

## Exercise笔记

### 2.1
