# Lab2

## ä¸€ã€æŒ‡å¯¼ä¹¦å­¦ä¹ ç¬”è®°

### 1ã€MIPS 4Kcçš„åœ°å€æ˜ å°„

åœ¨4Kc ä¸Šï¼Œè½¯ä»¶è®¿å­˜çš„è™šæ‹Ÿåœ°å€ä¼šå…ˆè¢«MMU ç¡¬ä»¶æ˜ å°„åˆ°ç‰©ç†åœ°å€ï¼Œéšåä½¿ç”¨ç‰©ç†åœ°å€æ¥è®¿é—®å†…å­˜æˆ–å…¶ä»–å¤–è®¾ã€‚ä¸æœ¬å®éªŒç›¸å…³çš„æ˜ å°„ä¸å¯»å€è§„åˆ™ï¼ˆå†…å­˜å¸ƒå±€ï¼‰å¦‚ä¸‹ï¼š

* è‹¥è™šæ‹Ÿåœ°å€å¤„äº `0x80000000~0x9fffffff` (kseg0)ï¼Œåˆ™å°†è™šæ‹Ÿåœ°å€çš„æœ€é«˜ä½ç½®0 å¾—åˆ°ç‰©ç†åœ°å€ï¼Œé€šè¿‡cache è®¿å­˜ã€‚è¿™ä¸€éƒ¨åˆ†ç”¨äºå­˜æ”¾å†…æ ¸ä»£ç ä¸æ•°æ®ã€‚
* è‹¥è™šæ‹Ÿåœ°å€å¤„äº `0xa0000000~0xbfffffff` (kseg1)ï¼Œåˆ™å°†è™šæ‹Ÿåœ°å€çš„æœ€é«˜3ä½ç½®0 å¾—åˆ°ç‰©ç†åœ°å€ï¼Œä¸é€šè¿‡cache è®¿å­˜ã€‚è¿™ä¸€éƒ¨åˆ†å¯ä»¥ç”¨äºè®¿é—®å¤–è®¾ã€‚
* è‹¥è™šæ‹Ÿåœ°å€å¤„äº `0x00000000~0x7fffffff` (kuseg)ï¼Œåˆ™éœ€è¦é€šè¿‡TLB è½¬æ¢æˆç‰©ç†åœ°å€ï¼Œå†é€šè¿‡cache è®¿å­˜ã€‚è¿™ä¸€éƒ¨åˆ†ç”¨äºå­˜æ”¾ç”¨æˆ·ç¨‹åºä»£ç ä¸æ•°æ®ã€‚

ä»¥ä¸Šçš„ **â€œå°†è™šæ‹Ÿåœ°å€æœ€é«˜xxä½ç½®0"** æŒ‡çš„æ˜¯ **äºŒè¿›åˆ¶ä¸‹** çš„åœ°å€ï¼Œè€Œéå†™å‡ºæ¥çš„åå…­è¿›åˆ¶ï¼ˆè¿™é‡Œæˆ‘æƒ³äº†å¥½ä¹…ï¼Œæ‰å‘ç°ä¸€ç›´åœ¨ç–‘æƒ‘çš„ç‚¹å®é™…æ˜¯æˆ‘ä¸€å¼€å§‹å°±æƒ³é”™äº†ï¼‰

åœ¨4Kc ä¸­ï¼Œä½¿ç”¨MMU æ¥å®Œæˆä¸Šè¿°åœ°å€æ˜ å°„ï¼ŒMMU é‡‡ç”¨ç¡¬ä»¶TLB æ¥å®Œæˆåœ°å€æ˜ å°„ã€‚TLBéœ€è¦ç”±è½¯ä»¶è¿›è¡Œå¡«å†™ï¼Œå³æ“ä½œç³»ç»Ÿå†…æ ¸è´Ÿè´£ç»´æŠ¤TLB ä¸­çš„æ•°æ®ã€‚æ‰€æœ‰å¯¹ä½2GB ç©ºé—´ï¼ˆkusegï¼‰çš„å†…å­˜è®¿é—®æ“ä½œéƒ½éœ€è¦ç»è¿‡TLBã€‚

### 2ã€åˆå§‹åŒ–åˆ†é…å†…å­˜

åœ¨æœªå»ºç«‹å†…å­˜ç®¡ç†æœºåˆ¶çš„æ—¶å€™ï¼Œéœ€è¦æ‰‹åŠ¨åˆ†é…å†…å­˜ã€‚

æ ¹æ®æ˜ å°„è§„åˆ™ï¼Œ0x80400000 å¯¹åº”çš„ç‰©ç†åœ°å€æ˜¯0x400000ã€‚åœ¨ç‰©ç†åœ°å€0x400000 çš„å‰é¢ï¼Œå­˜æ”¾ç€æ“ä½œç³»ç»Ÿå†…æ ¸çš„ä»£ç å’Œå®šä¹‰çš„å…¨å±€å˜é‡æˆ–æ•°ç»„ï¼ˆè¿˜é¢å¤–ä¿ç•™äº†ä¸€äº›ç©ºé—´ï¼‰ã€‚æ¥ä¸‹æ¥å°†ä»ç‰©ç†åœ°å€ 0x400000 å¼€å§‹åˆ†é…ç‰©ç†å†…å­˜ï¼Œç”¨äºå»ºç«‹ç®¡ç†å†…å­˜çš„æ•°æ®ç»“æ„ã€‚

* å°† `a`æŒ‰ `n`å¯¹é½

  ```
  #define ROUND(a, n) (((((u_long)(a)) + (n)-1)) & ~((n)-1))
  ```

### 3ã€é“¾è¡¨å®

* `LIST_HEAD(name, type)`ï¼Œåˆ›å»ºä¸€ä¸ªåç§°ä¸ºname é“¾è¡¨çš„å¤´éƒ¨ç»“æ„ä½“ï¼ŒåŒ…å«ä¸€ä¸ªæŒ‡å‘typeç±»å‹ç»“æ„ä½“çš„æŒ‡é’ˆï¼Œè¿™ä¸ªæŒ‡é’ˆå¯ä»¥æŒ‡å‘é“¾è¡¨çš„é¦–ä¸ªå…ƒç´ ã€‚
* `LIST_ENTRY(type)`ï¼Œä½œä¸ºä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹å‡ºç°ï¼Œä¾‹å¦‚å¯ä»¥è¿›è¡Œå¦‚ä¸‹çš„å®šä¹‰ï¼š

  ```
  LIST_ENTRY(Page) a;
  ```

  å®ƒçš„æœ¬è´¨æ˜¯ä¸€ä¸ªé“¾è¡¨é¡¹ï¼ŒåŒ…æ‹¬æŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆle_nextï¼Œä»¥åŠæŒ‡å‘å‰ä¸€ä¸ªå…ƒç´ é“¾è¡¨é¡¹ `le_next` çš„æŒ‡é’ˆ `le_prev`ã€‚`le_prev` æ˜¯ä¸€ä¸ªæŒ‡é’ˆçš„æŒ‡é’ˆï¼Œå®ƒçš„ä½œç”¨æ˜¯å½“åˆ é™¤ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæ›´æ”¹å‰ä¸€ä¸ªå…ƒç´ é“¾è¡¨é¡¹çš„ `le_next`ã€‚
* `LIST_EMPTY(head)`ï¼Œåˆ¤æ–­head æŒ‡é’ˆæŒ‡å‘çš„å¤´éƒ¨ç»“æ„ä½“å¯¹åº”çš„é“¾è¡¨æ˜¯å¦ä¸ºç©ºã€‚
* `LIST_FIRST(head)`ï¼Œå°†è¿”å›head å¯¹åº”çš„é“¾è¡¨çš„é¦–ä¸ªå…ƒç´ ã€‚
* `LIST_INIT(head)`ï¼Œå°†head å¯¹åº”çš„é“¾è¡¨åˆå§‹åŒ–ã€‚
* `LIST_NEXT(elm, field)`ï¼Œè¿”å›æŒ‡é’ˆelm æŒ‡å‘çš„å…ƒç´ åœ¨å¯¹åº”é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆã€‚`elm` æŒ‡é’ˆæŒ‡å‘çš„ç»“æ„ä½“éœ€è¦åŒ…å«ä¸€ä¸ªåä¸º `field` çš„å­—æ®µï¼Œç±»å‹æ˜¯ä¸€ä¸ªé“¾è¡¨é¡¹ `LIST_ENTRY(type)`ï¼Œä¸‹é¢å‡ºç°çš„ `field` å«ä¹‰å‡å’Œæ­¤ç›¸åŒã€‚
* `LIST_INSERT_AFTER(listelm, elm, field)`ï¼Œå°†elm æ’åˆ°å·²æœ‰å…ƒç´ listelm ä¹‹åã€‚
* `LIST_INSERT_BEFORE(listelm, elm, field)`ï¼Œå°† `elm` æ’åˆ°å·²æœ‰å…ƒç´  `listelm` ä¹‹å‰ã€‚
* `LIST_INSERT_HEAD(head, elm, field)`ï¼Œå°† `elm`æ’åˆ° `head` å¯¹åº”é“¾è¡¨çš„å¤´éƒ¨ã€‚
* `LIST_REMOVE(elm, field)`ï¼Œå°† `elm` ä»å¯¹åº”é“¾è¡¨ä¸­åˆ é™¤ã€‚

### 4ã€ä¸¤çº§é¡µè¡¨æœºåˆ¶

MOS ä¸­ç”¨ `PADDR` ä¸ `KADDR` è¿™ä¸¤ä¸ªå®å¯ä»¥å¯¹ä½äº `kseg0` çš„è™šæ‹Ÿåœ°å€å’Œå¯¹åº”çš„ç‰©ç†åœ°å€è¿›è¡Œè½¬æ¢ã€‚
ä½†æ˜¯ï¼Œå¯¹äºä½äº `kuseg` çš„è™šæ‹Ÿåœ°å€ï¼ŒMOS ä¸­é‡‡ç”¨ä¸¤çº§é¡µè¡¨ç»“æ„å¯¹å…¶è¿›è¡Œåœ°å€è½¬æ¢ã€‚

ä¸¤çº§é¡µè¡¨ä¹Ÿå°±æ˜¯ç»™é¡µè¡¨å†åŠ ä¸€ä¸ªé¡µè¡¨ï¼ŒåŸæ¥çš„é¡µè¡¨æ˜¯äºŒçº§é¡µè¡¨ï¼ŒäºŒçº§é¡µè¡¨çš„é¡µè¡¨æ˜¯ä¸€çº§é¡µè¡¨ï¼Œä¹Ÿå«é¡µç›®å½•ã€‚

é‚£ä¹ˆå¯¹äº32ä½çš„è™šæ‹Ÿåœ°å€ï¼Œä»ä½åˆ°é«˜ä»0 å¼€å§‹ç¼–å·ï¼Œå…¶31-22 ä½è¡¨ç¤ºçš„æ˜¯ä¸€çº§é¡µè¡¨é¡¹çš„åç§»é‡ï¼Œ21-12 ä½è¡¨ç¤ºçš„æ˜¯äºŒçº§é¡µè¡¨é¡¹çš„åç§»é‡ï¼Œ11-0 ä½è¡¨ç¤ºçš„æ˜¯é¡µå†…åç§»é‡ã€‚

è®¿é—®è™šæ‹Ÿåœ°å€æ—¶ï¼Œå…ˆé€šè¿‡ä¸€çº§é¡µè¡¨åŸºåœ°å€å’Œä¸€çº§é¡µè¡¨é¡¹çš„åç§»é‡ï¼Œæ‰¾åˆ°å¯¹åº”çš„ä¸€çº§é¡µè¡¨é¡¹ï¼Œå¾—åˆ°å¯¹åº”çš„äºŒçº§é¡µè¡¨çš„ç‰©ç†é¡µå·ï¼Œå†æ ¹æ®äºŒçº§é¡µè¡¨é¡¹çš„åç§»é‡æ‰¾åˆ°æ‰€éœ€çš„äºŒçº§é¡µè¡¨é¡¹ï¼Œè¿›è€Œå¾—åˆ°è¯¥è™šæ‹Ÿåœ°å€å¯¹åº”çš„ç‰©ç†é¡µå·ã€‚

MIPS 4Kc å‘å‡ºçš„åœ°å€å‡ä¸ºè™šæ‹Ÿåœ°å€ï¼Œå› æ­¤å¦‚æœç¨‹åºæƒ³è®¿é—®æŸä¸ªç‰©ç†åœ°å€ï¼Œéœ€è¦é€šè¿‡æ˜ å°„åˆ°è¯¥ç‰©ç†åœ°å€çš„è™šæ‹Ÿåœ°å€æ¥è®¿é—®ã€‚å¯¹é¡µè¡¨è¿›è¡Œæ“ä½œæ—¶ç¡¬ä»¶å¤„äºå†…æ ¸æ€ï¼Œå› æ­¤ä½¿ç”¨å® `KADDR` è·å¾—å…¶ä½äº `kseg0` ä¸­çš„è™šæ‹Ÿåœ°å€å³å¯å®Œæˆè½¬æ¢ã€‚

æ— è®ºæ˜¯ä¸€çº§é¡µè¡¨è¿˜æ˜¯äºŒçº§é¡µè¡¨ï¼Œå®ƒä»¬çš„ç»“æ„éƒ½ä¸€æ ·ï¼Œåªä¸è¿‡æ¯ä¸ªé¡µè¡¨é¡¹è®°å½•çš„ç‰©ç†é¡µå·å«ä¹‰æœ‰æ‰€ä¸åŒã€‚æ¯ä¸ªé¡µè¡¨å‡ç”±1024 ä¸ªé¡µè¡¨é¡¹ç»„æˆï¼Œæ¯ä¸ªé¡µè¡¨é¡¹ç”±32 ä½ç»„æˆï¼ŒåŒ…æ‹¬20 ä½ç‰©ç†é¡µå·ä»¥åŠ12 ä½æ ‡å¿—ä½ã€‚å…¶ä¸­ï¼Œ12 ä½æ ‡å¿—ä½åŒ…å«é«˜6 ä½ç¡¬ä»¶æ ‡å¿—ä½ä¸ä½6 ä½è½¯ä»¶æ ‡å¿—ä½ã€‚
å½“é¡µè¡¨é¡¹éœ€è¦å€ŸåŠ©EntryLo å¯„å­˜å™¨å¡«å…¥TLB æ—¶ï¼Œé¡µè¡¨é¡¹ä¼šè¢«å³ç§»6 ä½ï¼Œç§»å‡ºæ‰€æœ‰è½¯ä»¶æ ‡å¿—ä½ï¼Œä»…å°†é«˜20 ä½ç‰©ç†é¡µå·ä»¥åŠ6 ä½ç¡¬ä»¶æ ‡å¿—ä½å¡«å…¥TLB ä½¿ç”¨ã€‚æ¯ä¸ªé¡µè¡¨æ‰€å çš„ç©ºé—´ä¸º4KBï¼Œæ°å¥½ä¸ºä¸€ä¸ªç‰©ç†é¡µé¢çš„å¤§å°ã€‚

### 5ã€ä¸¤çº§é¡µè¡¨é¡¹çš„12ä½æ ‡è¯†ä½

é«˜6 ä½ç¡¬ä»¶æ ‡å¿—ä½ç”¨äºå­˜å…¥ `EntryLo` å¯„å­˜å™¨ä¸­ï¼Œä¾›ç¡¬ä»¶ä½¿ç”¨ï¼›
ä½6 ä½è½¯ä»¶æ ‡å¿—ä½ä¸ä¼šè¢«å­˜å…¥ TLB ä¸­ï¼Œä»…ä¾›è½¯ä»¶ä½¿ç”¨ã€‚

ä»¥ä¸‹æ˜¯å…­ä½ç¡¬ä»¶æ ‡å¿—ä½ï¼š

```c
PTE_V æœ‰æ•ˆä½ï¼Œè‹¥æŸé¡µè¡¨é¡¹çš„æœ‰æ•ˆä½ä¸º1ï¼Œåˆ™è¯¥é¡µè¡¨é¡¹æœ‰æ•ˆï¼Œå…¶ä¸­é«˜20 ä½å°±æ˜¯å¯¹åº”çš„ç‰©ç†é¡µå·ã€‚

PTE_D å¯å†™ä½ï¼Œè‹¥æŸé¡µè¡¨é¡¹çš„å¯å†™ä½ä¸º1ï¼Œåˆ™å…è®¸ç»ç”±è¯¥é¡µè¡¨é¡¹å¯¹ç‰©ç†é¡µè¿›è¡Œå†™æ“ä½œã€‚

PTE_G å…¨å±€ä½ï¼Œè‹¥æŸé¡µè¡¨é¡¹çš„å…¨å±€ä½ä¸º1ï¼Œåˆ™TLB ä»…é€šè¿‡è™šé¡µå·åŒ¹é…è¡¨é¡¹ï¼Œè€Œä¸åŒ¹é…ASIDï¼Œå°†åœ¨Lab3 ä¸­ç”¨äºæ˜ å°„pages å’Œenvs åˆ°ç”¨æˆ·ç©ºé—´ã€‚æœ¬Lab ä¸­å¯ä»¥å¿½ç•¥ã€‚

PTE_C_CACHEABLE å¯ç¼“å­˜ä½ï¼Œé…ç½®å¯¹åº”é¡µé¢çš„è®¿é—®å±æ€§ä¸ºå¯ç¼“å­˜ã€‚é€šå¸¸å¯¹äºæ‰€æœ‰ç‰©ç†é¡µé¢ï¼Œéƒ½å°†å…¶é…ç½®ä¸ºå¯ç¼“å­˜ï¼Œä»¥å…è®¸CPU ä½¿ç”¨cache åŠ é€Ÿå¯¹è¿™äº›é¡µé¢çš„è®¿å­˜è¯·æ±‚ã€‚

PTE_COW å†™æ—¶å¤åˆ¶ä½ï¼Œå°†åœ¨Lab4 ä¸­ç”¨åˆ°ï¼Œç”¨äºå®ç° fork çš„å†™æ—¶å¤åˆ¶æœºåˆ¶ã€‚æœ¬Labä¸­å¯ä»¥å¿½ç•¥ã€‚

PTE_LIBRARY å…±äº«é¡µé¢ä½ï¼Œå°†åœ¨Lab6 ä¸­ç”¨åˆ°ï¼Œç”¨äºå®ç°ç®¡é“æœºåˆ¶ã€‚æœ¬Lab ä¸­å¯ä»¥å¿½ç•¥ã€‚
```

### 6ã€4Kc ä¸­ä¸å†…å­˜ç®¡ç†ç›¸å…³çš„CP0 å¯„å­˜å™¨ï¼š

```c
8 		BadVaddr 				ä¿å­˜å¼•å‘åœ°å€å¼‚å¸¸çš„è™šæ‹Ÿåœ°å€
10ã€2ã€3 	EntryHiã€EntryLo0ã€EntryLo1		æ‰€æœ‰è¯»å†™TLB çš„æ“ä½œéƒ½è¦é€šè¿‡è¿™ä¸‰ä¸ªå¯„å­˜å™¨ï¼Œè¯¦è§ä¸‹ä¸€å°èŠ‚
0 		Index 					TLB è¯»å†™ç›¸å…³éœ€è¦ç”¨åˆ°è¯¥å¯„å­˜å™¨
1 		Random					éšæœºå¡«å†™TLB è¡¨é¡¹æ—¶éœ€è¦ç”¨åˆ°è¯¥å¯„å­˜å™¨
```

### 7ã€EntryHiã€EntryLo0ã€EntryLo1

EntryHiã€EntryLo0ã€EntryLo1 éƒ½æ˜¯CP0 ä¸­çš„å¯„å­˜å™¨ï¼Œä»–ä»¬åªæ˜¯åˆ†åˆ«å¯¹åº”åˆ°TLB çš„Keyä¸ä¸¤ç»„Dataï¼Œå¹¶ä¸æ˜¯TLB æœ¬èº«ã€‚

å…¶ä¸­ EntryLo0ã€EntryLo1 æ‹¥æœ‰å®Œå…¨ç›¸åŒçš„ä½ç»“æ„ï¼ŒEntryLo0 å­˜å‚¨ Key å¯¹åº”çš„å¶é¡µè€ŒEntryLo1 å­˜å‚¨Key å¯¹åº”çš„å¥‡é¡µã€‚

### 8ã€TLBç›¸å…³æŒ‡ä»¤

* `tlbr`ï¼šä»¥ `Index` å¯„å­˜å™¨ä¸­çš„å€¼ä¸ºç´¢å¼•ï¼Œè¯»å‡º `TLB` ä¸­å¯¹åº”çš„è¡¨é¡¹åˆ° `EntryHi` ä¸ `EntryLo0`ã€`EntryLo1`ã€‚
* `tlbwi`ï¼šä»¥ `Index` å¯„å­˜å™¨ä¸­çš„å€¼ä¸ºç´¢å¼•ï¼Œå°†æ­¤æ—¶ `EntryHi` ä¸ `EntryLo0`ã€`EntryLo1` çš„å€¼å†™åˆ°ç´¢å¼•æŒ‡å®šçš„ `TLB` è¡¨é¡¹ä¸­ã€‚
* `tlbwr`ï¼šå°† `EntryHi` ä¸ `EntryLo0`ã€`EntryLo1` çš„æ•°æ®éšæœºå†™åˆ°ä¸€ä¸ª `TLB` è¡¨é¡¹ä¸­ï¼ˆæ­¤å¤„ä½¿ç”¨ `Random` å¯„å­˜å™¨æ¥â€œéšæœºâ€æŒ‡å®šè¡¨é¡¹ï¼Œ`Random` å¯„å­˜å™¨æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªä¸åœè¿è¡Œçš„å¾ªç¯è®¡æ•°å™¨ï¼‰ã€‚
* `tlbp`ï¼šæ ¹æ® `EntryHi` ä¸­çš„ `Key`ï¼ˆåŒ…å« `VPN` ä¸ `ASID`ï¼‰ï¼ŒæŸ¥æ‰¾ `TLB` ä¸­ä¸ä¹‹å¯¹åº”çš„è¡¨é¡¹ï¼Œå¹¶å°†è¡¨é¡¹çš„ç´¢å¼•å­˜å…¥ `Index` å¯„å­˜å™¨ï¼ˆè‹¥æœªæ‰¾åˆ°åŒ¹é…é¡¹ï¼Œåˆ™ `Index` æœ€é«˜ä½è¢«ç½®1ï¼‰ã€‚

---

---

## Exerciseç¬”è®°

![B3log Logo](/Users/mawenban/Desktop/CPU-TLB-Memory.png)

è¿™æ¬¡Labçš„é¢˜ç›®å…³è”æ€§æ¯”è¾ƒå¼ºï¼Œæ²¡æ³•æŒ‰é¢˜å·æ¥å†™ï¼Œæ‰€ä»¥å°±ç›´æ¥æŒ‰Bootè°ƒç”¨æµç¨‹æ¥å†™

åœ¨è·³è½¬ `init.c`ä¹‹åï¼Œè°ƒç”¨ `mips_init`å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°è°ƒç”¨ä¸‰ä¸ªå‡½æ•°ï¼š

* **`mips_detect_memory(u_int _memsize)`** ï¼Œä½œç”¨æ˜¯æ¢æµ‹ç¡¬ä»¶å¯ç”¨å†…å­˜ï¼Œå¹¶å¯¹ä¸€äº›å’Œå†…å­˜ç®¡
  ç†ç›¸å…³çš„å˜é‡è¿›è¡Œåˆå§‹åŒ–ã€‚
* **`mips_vm_init()`** ï¼Œä½œç”¨æ˜¯ä¸ºå†…å­˜ç®¡ç†æœºåˆ¶ä½œå‡†å¤‡ï¼Œå»ºç«‹ä¸€äº›ç”¨äºç®¡ç†çš„æ•°æ®ç»“æ„ã€‚
* **`page_init()`** ï¼Œå®ç°ä½äºkern/pmap.c ä¸­ï¼Œä½œç”¨æ˜¯åˆå§‹åŒ–pages æ•°ç»„ä¸­çš„Page ç»“æ„ä½“ä»¥
  åŠç©ºé—²é“¾è¡¨ã€‚è¿™ä¸ªå‡½æ•°çš„å…·ä½“åŠŸèƒ½ä¼šåœ¨åé¢è¯¦ç»†æè¿°ã€‚

---

### é¦–å…ˆæ˜¯mips_detect_memory(u_int _memsize)

```c
u_long npage;	       /* Amount of memory(in pages) */

void mips_detect_memory(u_int _memsize) {
	/* Step 1: Initialize memsize. */
	memsize = _memsize;

	/* Step 2: Calculate the corresponding 'npage' value. */
	/* Exercise 2.1: Your code here. */

	npage=memsize/PAGE_SIZE;

	printk("Memory size: %lu KiB, number of pages: %lu\n", memsize / 1024, npage);
}
```

è¿™é‡Œæœ‰ä¸€ä¸ªéœ€è¦æ’å…¥çš„åœ°æ–¹ï¼Œæç¤ºä¸º **è®¡ç®—ç›¸åº”çš„ `npage`å€¼** ï¼Œå³è®¡ç®—æ€»ç‰©ç†é¡µæ•°ã€‚
å…¶ä¸­ `memsize`ä¸ºæ€»ç‰©ç†å†…å­˜å¯¹åº”çš„å­—èŠ‚æ•°ï¼Œæ¥æ”¶ä¼ å…¥çš„ `u_int _memsize`å¹¶åˆå§‹åŒ–ã€‚

å·²çŸ¥ç‰©ç†å†…å­˜æ€»å­—èŠ‚æ•°ï¼Œæ±‚æ€»ç‰©ç†é¡µæ•°ï¼Œåªéœ€è¦çŸ¥é“æ¯é¡µå­—èŠ‚æ•°ï¼Œé‚£ä¹ˆå°±å¼€å§‹æ‰¾ï¼ˆè‹±æ–‡ç¡®å®ä¸å¥½æ‰¾ï¼‰ï¼Œ
æœ€ååœ¨ `mmu.h`ä¸­å¯ä»¥æ‰¾åˆ°

```
#define PAGE_SIZE 4096
```

ç‰©ç†é¡µå­—èŠ‚æ•°ä¸º4Kï¼Œé™¤ç‰©ç†å†…å­˜æ€»å­—èŠ‚æ•°å³å¯æ±‚å¾— `npage`ã€‚

---

### æ¥ä¸‹æ¥æ˜¯mips_vm_init()

```c
/* Overview:
    Set up two-level page table. */
void mips_vm_init() {
	/* Allocate proper size of physical memory for global array `pages`,
	 * for physical memory management. Then, map virtual address `UPAGES` to
	 * physical address `pages` allocated before. For consideration of alignment,
	 * you should round up the memory size before map. */
	pages = (struct Page *)alloc(npage * sizeof(struct Page), PAGE_SIZE, 1);
	printk("to memory %x for struct Pages.\n", freemem);
	printk("pmap.c:\t mips vm init success\n");
}
```

å…¶ä¸»è¦åŠŸèƒ½æ˜¯ç”¨ `alloc(u_intn, u_intalign, intclear)`å‡½æ•°ä¸ºæ•°ç»„ `pages`åˆ†é…å†…å­˜ï¼Œè¦è€ƒè™‘å¯¹é½ã€‚

å…¶å†…å®¹å¦‚ä¸‹

```c
void *alloc(u_int n, u_int align, int clear) {
	extern char end[];
	u_long alloced_mem;

	if (freemem == 0) {
		freemem = (u_long)end; // end
	}

	freemem = ROUND(freemem, align);

	alloced_mem = freemem;

	freemem = freemem + n;

	panic_on(PADDR(freemem) >= memsize);

	if (clear) {
		memset((void *)alloced_mem, 0, n);
	}

	return (void *)alloced_mem;
}
```

æ­¤å‡½æ•°çš„åŠŸèƒ½å°±æ˜¯ç”¨äºåˆ†é…å†…å­˜ç©ºé—´ï¼ˆåœ¨å»ºç«‹é¡µå¼å†…å­˜ç®¡ç†æœºåˆ¶ä¹‹å‰ä½¿ç”¨ï¼‰ã€‚
è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯åˆ†é…n å­—èŠ‚çš„ç©ºé—´å¹¶è¿”å›åˆå§‹çš„è™šæ‹Ÿåœ°å€ï¼ŒåŒæ—¶å°†åœ°å€æŒ‰ align å­—èŠ‚å¯¹é½ï¼ˆä¿è¯align å¯ä»¥æ•´é™¤åˆå§‹è™šæ‹Ÿåœ°å€ï¼‰ï¼Œè‹¥clear ä¸ºçœŸï¼Œåˆ™å°†å¯¹åº”å†…å­˜ç©ºé—´çš„å€¼æ¸…é›¶ï¼Œå¦åˆ™ä¸æ¸…é›¶ã€‚

çœ‹åˆ°è¿™é‡Œæˆ‘ä»¬å¯èƒ½æœ‰ä¸€ä¸ªç–‘é—®ï¼šç°åœ¨è¿˜æ²¡æœ‰å»ºç«‹å†…å­˜ç®¡ç†æœºåˆ¶ï¼Œé‚£ä¹ˆå†…æ ¸æ˜¯å¦‚ä½•æ“ä½œå†…å­˜çš„å‘¢ï¼Ÿ
è€ƒè™‘ `kseg0`æ®µçš„æ€§è´¨ï¼Œè¯¥æ®µä¸Šçš„è™šæ‹Ÿåœ°å€è¢«çº¿æ€§æ˜ å°„åˆ°ç‰©ç†åœ°å€ï¼Œæ“ä½œç³»ç»Ÿé€šè¿‡è®¿é—®è¯¥æ®µçš„åœ°å€æ¥ç›´æ¥æ“ä½œç‰©ç†å†…å­˜ï¼Œä»è€Œé€æ­¥å»ºç«‹å†…å­˜ç®¡ç†æœºåˆ¶ã€‚ä¾‹å¦‚å½“å†™è™šæ‹Ÿåœ°å€ `0x80012340`æ—¶ï¼Œç”±äº `kseg0` æ®µçš„æ€§è´¨ï¼Œäº‹å®ä¸Šåœ¨å†™ç‰©ç†åœ°å€ `0x12340`ã€‚

ä¸‹é¢é€è¡Œæ¥è§£æè¿™ä¸ªå‡½æ•°ï¼š

`extern char end[]` æ˜¯Lab1ä¸­è¿æ¥å™¨ `kernel.lds`è„šæœ¬æ‰€åˆå§‹åŒ–çš„

```
. = 0x80400000;
end = . ;
```

å³åˆå§‹åŒ–å†…æ ¸çš„æ—¶å€™ç»™å†…æ ¸æ‰€åˆ†é…çš„ç»“æŸåœ°å€ï¼ˆè™šæ‹Ÿåœ°å€ï¼‰ï¼Œæ¥ä¸‹æ¥å°†ä»ç‰©ç†åœ°å€ 0x400000 å¼€å§‹åˆ†é…ç‰©ç†å†…å­˜ï¼Œç”¨äºå»ºç«‹ç®¡
ç†å†…å­˜çš„æ•°æ®ç»“æ„ `pages`ã€‚

* `alloc`å‡½æ•°ä¸­ç”¨ä¸€ä¸ª `char`æ•°ç»„å»è·å– `end`å¹¶ç”¨å¼ºåˆ¶ç±»å‹è½¬æ¢å–å…¶åœ°å€åˆ° `freedom`ã€‚
* ä¹‹åå°† `freedom`æŒ‰ `allign`å¯¹é½ï¼Œ`ROUND`å‡½æ•°å…¶å®å°±æ˜¯ä¸€ä¸ªå‘ä¸Šå–æ•´çš„é«˜æ–¯å‡½æ•°ï¼Œä½¿å¾— `freedom`è¢« `allign`æ•´é™¤ã€‚
* å·²ç»è¢«åˆ†é…çš„å†…å­˜ `alloced_mem`å³ä¸ºæ­¤æ—¶çš„ `freedom`ï¼Œ
* éšååœ¨ `freedom`ä¹‹ååˆ†é…å¤§å°ä¸º `n`å­—èŠ‚çš„å†…å­˜å¹¶ç½®0ï¼Œ
* æœ€åè¿”å›æ‰€åˆ†é…çš„å†…å­˜é¦–åœ°å€æŒ‡é’ˆ `alloced_mem`ã€‚

è¿™æ®µä»£ç é‡Œé¢çš„ `PADDR`å¼•å‡ºäº†ä¸€ç³»åˆ—è™šæ‹Ÿåœ°å€å’Œç‰©ç†åœ°å€ä¹‹é—´è½¬æ¢çš„å‡½æ•°

```
//å¤§æ¦‚æ˜¯UserLimitï¼Œå³ç»™ç”¨æˆ·åˆ†é…ç©ºé—´çš„æé™å€¼ï¼Œæ­¤åœ°å€ä¹‹åæ˜¯å†…æ ¸æ‰€å ç”¨çš„ã€‚
#define ULIM 0x80000000

//å°†å†…æ ¸è™šæ‹Ÿåœ°å€è½¬æ¢ä¸ºç‰©ç†åœ°å€kernel->physical
#define PADDR(kva)                                                                                 \
	({                                                                                         \
		u_long _a = (u_long)(kva);                                                         \
		if (_a < ULIM)                                                                     \
			panic("PADDR called with invalid kva %08lx", _a);                          \
		_a - ULIM;                                                                         \
	})

//å°†ç‰©ç†åœ°å€è½¬æ¢ä¸ºå†…æ ¸è™šæ‹Ÿåœ°å€physical->kernel
#define KADDR(pa)                                                                                  \
	({                                                                                         \
		u_long _ppn = PPN(pa);                                                             \
		if (_ppn >= npage) {                                                               \
			panic("KADDR called with invalid pa %08lx", (u_long)pa);                   \
		}                                                                                  \
		(pa) + ULIM;                                                                       \
	})

```

é‚£ä¹ˆç°åœ¨å›å¤´çœ‹mips_vm_init()ä¸­æ‰€è°ƒç”¨çš„

```c
pages = (struct Page *)alloc(npage * sizeof(struct Page), PAGE_SIZE, 1);
```

æ·±å…¥ç ”ç©¶åæˆ‘ä»¬å‘ç°ï¼Œè¿™æ¡è¯­å¥åº•å±‚æ˜¯åœ¨
å°†è™šæ‹Ÿå†…å­˜ä¸­ä»£è¡¨ç©ºé—²ç©ºé—´æˆªæ­¢åœ°å€çš„ `freedom`å¢åŠ  `npageâ€”â€”ç‰©ç†æ€»é¡µæ•°`ä¸ªé¡µçš„å¤§å°ï¼Œå³å°†å…¶åç§»å¯¹åº”å¤§å°çš„ä½ç§»ï¼Œ
åŒæ—¶ï¼ŒæŒ‰ç…§ `PAGE_SIZEâ€”â€”ç‰©ç†é¡µå¤§å°`æ¥å¯¹é½ï¼Œå¹¶å¯¹æ‰€åˆ†é…çš„å†…å­˜æ¸…é›¶ã€‚

---

### æ¥ä¸‹æ¥æ˜¯page_init()

è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯åˆå§‹åŒ–ç©ºé—²åˆ—è¡¨é¡µ

åœ¨å¼€å§‹è¿™ä¸ªå‡½æ•°çš„è§£æä¹‹å‰ï¼Œå°±ä¸å¾—ä¸å…ˆæ¥æ¢ç©¶è¿™ä¸ª **é¡µç»“æ„ä½“** ã€‚

MOS ä¸­ç»´æŠ¤äº† `npage` ä¸ªé¡µæ§åˆ¶å—ï¼Œä¹Ÿå°±æ˜¯ `Page` ç»“æ„ä½“ã€‚æ¯ä¸€ä¸ªé¡µæ§åˆ¶å—å¯¹åº”ä¸€é¡µçš„ç‰©ç†å†…å­˜ï¼ŒMOS ç”¨è¿™ä¸ªç»“æ„ä½“æ¥æŒ‰é¡µç®¡ç†ç‰©ç†å†…å­˜çš„åˆ†é…ã€‚

åœ¨ **ä¸€ã€3ã€** ä¸­ï¼Œå·²ç»åˆ—å‡ºæ¥äº†å¤§éƒ¨åˆ†æœ‰å…³è¿™äº›ç»“æ„ä½“çš„å®ï¼Œä½†æ˜¯å…¶å®æœ€éš¾ç†è§£çš„æ˜¯é¡µç»“æ„ä½“æœ¬èº«ï¼ï¼ï¼

***LIST_ENTRY(type)ï¼ï¼ï¼***

é“¾è¡¨å®ä½“ï¼š

```
#define LIST_ENTRY(type)                                                                           \
	struct {                                                                                   \
		struct type *le_next;  /* next element */                                          \
		struct type **le_prev; /* address of previous next element */                      \
	}
```

è¿™é‡Œå…¶å®ç±»ä¼¼Javaç­‰é«˜çº§è¯­è¨€ä¸­çš„æ³›å‹æ¦‚å¿µï¼Œåªä¸è¿‡æ˜¯ç”¨å®ï¼ˆæ›¿æ¢ï¼‰æ¥å®ç°çš„ã€‚

è¿™é‡Œæœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œå­—é¢æ„æ€ï¼Œä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªé“¾è¡¨å®ä½“ï¼Œå¦ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸Šä¸€ä¸ªé“¾è¡¨å®ä½“ã€‚

ä½†æ˜¯ï¼Œæœ€çƒ§è„‘çš„æ¥äº†ï¼å…¶ä¸­ `le_prev`è¿™ä¸ªæŒ‡é’ˆï¼Œå®ƒçš„å€¼å¹¶ä¸æ˜¯é“¾è¡¨ä¸­ä¸Šä¸ªç»“æ„ä½“çš„åœ°å€ï¼Œè€Œæ˜¯é“¾è¡¨ä¸­ä¸Šä¸€ä¸ªç»“æ„ä½“æŒ‡é’ˆ `le_next`çš„åœ°å€ï¼Œ
æ›´è¿›ä¸€æ­¥è¯´ï¼Œ`*le_prev`çš„å€¼æ˜¯é“¾è¡¨ä¸­ä¸Šä¸€ä¸ªç»“æ„ä½“çš„ `le_next`ï¼Œå³ `**le_prev`çš„å€¼å¯¹åº”çš„æ˜¯å½“å‰é“¾è¡¨é¡¹ã€‚

å¦‚å›¾ï¼š

![img](/Users/mawenban/Desktop/LIST_ENTRY.png)

**ä½†æ˜¯ï¼ï¼ï¼**

è¿™è¿˜æ²¡æœ‰ç»“æŸï¼š

```c
typedef LIST_ENTRY(Page) Page_LIST_entry_t;

struct Page {
	Page_LIST_entry_t pp_link; /* free list link */

	u_short pp_ref;
};
```

è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼š

```c
struct {                                                                                   \
		struct type *le_next;  /* next element */                                  \
		struct type **le_prev; /* address of previous next element */              \
	} Page_LIST_entry_t;

struct Page {
	Page_LIST_entry_t pp_link; /* free list link */

	u_short pp_ref;
};
```

è¿™é‡Œçš„ `Page_LIST_entry_t`ç›¸å½“äº `Page`ç»“æ„ä½“åŒå‘é“¾è¡¨ä¸­çš„ä¸¤ä¸ªæŒ‡é’ˆï¼Œåªä¸è¿‡å®ç°æ–¹å¼ç•¥æœ‰ä¸åŒï¼Œ
ä¹Ÿå°±æ˜¯è¯´ï¼Œ`Page`ç»“æ„ä½“å°±æ˜¯ä¸€ä¸ªåˆæ ¼çš„é“¾è¡¨é¡¹å½¢å¼ï¼Œ
å…¶ä¸­çš„ `pp_ref`æ˜¯åé¢è¦ç”¨åˆ°çš„æ ‡è®°æ•°å­—ï¼Œä»£è¡¨è¿™ä¸€é¡µç‰©ç†å†…å­˜è¢«å¼•ç”¨çš„æ¬¡æ•°ï¼Œå®ƒç­‰äºæœ‰å¤šå°‘è™šæ‹Ÿé¡µæ˜ å°„åˆ°è¯¥ç‰©ç†é¡µã€‚

---

#### è¶çƒ­æ‰“é“ï¼Œæ°å¥½ä¸‹ä¸€é“ç»ƒä¹ é¢˜å°±æ˜¯ç»å…¸çš„é“¾è¡¨æ’å…¥ã€‚

```
#define LIST_INSERT_AFTER(listelm, elm, field) 						\
 	do { 										\
	 	if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)    \
		LIST_NEXT((listelm), field)->field.le_prev = &LIST_NEXT((elm), field);  \
	 	LIST_NEXT((listelm), field) = (elm); 					\
	 	(elm)->field.le_prev = &LIST_NEXT((listelm), field); 			\
 	} while (0)
```

è¿™é‡Œå’Œåˆå­¦æ•°æ®ç»“æ„æ—¶å€™å¤„ç†åŒå‘é“¾è¡¨æ’å…¥å¾ˆç›¸ä¼¼ï¼Œéœ€è¦è€ƒè™‘çš„å¾ˆå®Œå…¨ï¼Œ
è¿™é‡Œçš„LIST_NEXT()å…¶å®å°±æ˜¯å–æŒ‡é’ˆæ¢äº†ä¸ªå†™æ³•ï¼š

```
#define LIST_NEXT(elm, field) ((elm)->field.le_next)
```

è¿™é‡Œåç»­ä¼ å…¥çš„ `elm`éƒ½æ˜¯æŒ‡é’ˆç±»å‹ï¼Œæ¯”å¦‚ `Page*`ï¼Œæ‰€ä»¥æœ‰ `(elm)->field.le_prev`è¿™æ ·çš„å†™æ³•ï¼Œ
ä»¥åŠ `LIST_NEXT((listelm), field) = (elm);`è¿™æ ·çš„è¯­å¥ã€‚

---

æ¥ç€ï¼Œæˆ‘ä»¬å›åˆ°äº†ç‰©ç†å†…å­˜ç®¡ç†ã€‚

**Noteï¼š** `npage` ä¸ª `Page` å’Œ `npage` ä¸ªç‰©ç†é¡µé¢ä¸€ä¸€é¡ºåºå¯¹åº”ã€‚å…·ä½“æ¥è¯´ï¼Œç”¨ä¸€ä¸ªæ•°ç»„å­˜æ”¾è¿™äº› `Page` ç»“æ„ä½“ï¼Œé¦–ä¸ª `Page` çš„åœ°å€ä¸º `P`ï¼Œåˆ™ `P[i] `å¯¹åº”ä»0 å¼€å§‹è®¡æ•°çš„ç¬¬ `i`ä¸ªç‰©ç†é¡µé¢ã€‚`Page` ä¸å…¶å¯¹åº”çš„ç‰©ç†é¡µé¢åœ°å€çš„è½¬æ¢å¯ä»¥ä½¿ç”¨ `include/pmap.h` ä¸­çš„ `page2pa` å’Œ `pa2page` è¿™ä¸¤ä¸ªå‡½æ•°ã€‚

ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ `include/pmap.h` ä¸­è¿™å‡ ä¸ªåœ°å€ä¹‹é—´ç›¸äº’è½¬æ¢çš„å‡½æ•°

```c
static inline u_long page2ppn(struct Page *pp) {
	return pp - pages;
}

static inline u_long page2pa(struct Page *pp) {
	return page2ppn(pp) << PGSHIFT;
}

static inline struct Page *pa2page(u_long pa) {
	if (PPN(pa) >= npage) {
		panic("pa2page called with invalid pa: %x", pa);
	}
	return &pages[PPN(pa)];
}

static inline u_long page2kva(struct Page *pp) {
	return KADDR(page2pa(pp));
}
```

* `page2ppn`ï¼šç”±äº `pp`å’Œ `pages`éƒ½æ˜¯ `Page*`ç±»å‹ï¼Œæ‰€ä»¥äºŒè€…ç›¸å‡å°±æ˜¯ `pp`åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ï¼Œåˆç”±äº `pages`æ˜¯ç‰©ç†é¡µæ§åˆ¶å—æ•°ç»„ï¼Œå…¶ä¸­å…ƒç´ ä¸ç‰©ç†é¡µä¸€ä¸€å¯¹åº”ï¼Œæ‰€ä»¥ `pp`çš„ç´¢å¼•å°±æ˜¯ç‰©ç†é¡µå·ã€‚
* `page2pa`ï¼šè¿™é‡Œçš„ `PGSHIFT`å®šä¹‰åœ¨ `mmu.h`ï¼š`#define PGSHIFT 12`ï¼Œå°†é¡µç»è¿‡ä¸Šä¸€ä¸ªå‡½æ•°æ¥è·å¾—é¡µå·ï¼Œå†å·¦ç§»åäºŒä½ï¼Œå°±å–åˆ°äº†å‰äºŒåä½ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªé¡µçš„é¡µå·ï¼ˆç‰©ç†é¡µå…±1Mä¸ªï¼Œå³2^20ä¸ªï¼‰ã€‚
* `pa2page`ï¼šé€šè¿‡é¡µåœ°å€å–å¾—é¡µå·ï¼Œåœ¨ä¸è¶…è¿‡ç‰©ç†æ€»é¡µæ•°çš„æƒ…å†µä¸‹ï¼Œåœ¨ `pages`æ•°ç»„ä¸­å–å¾—å¯¹åº”çš„é¡µã€‚
* `page2kva`ï¼šå…ˆå°†é¡µé€šè¿‡ `page2pa`å‡½æ•°è½¬åŒ–ä¸ºé¡µç‰©ç†åœ°å€ï¼Œå†é€šè¿‡ `KADDR`å®ï¼Œè½¬åŒ–ä¸ºå†…æ ¸æ€ä½¿ç”¨çš„è™šæ‹Ÿåœ°å€ã€‚

ä»¥ä¸‹æ˜¯é‡è¦ç»“æ„ä½“ `Page_list`å®šä¹‰ï¼š

```c
struct Page_list{
	struct Page{
		struct {                                                                                   \
			struct type *le_next;  /* next element */                                  \
			struct type **le_prev; /* address of previous next element */              \
		} pp_link;
		u_short pp_ref;
	}* lh_first;
}
```

---

#### ç°åœ¨ç»ˆäºå¼€å§‹page_init()å‡½æ•°ï¼Œè¯ä¸å¤šè¯´ï¼Œå…ˆä¸Šä»£ç ï¼š

```c
void page_init(void) {
	/* Step 1: Initialize page_free_list. */
	LIST_INIT(&page_free_list);

	/* Step 2: Align `freemem` up to multiple of PAGE_SIZE. */
	freemem = ROUND(freemem, PAGE_SIZE);

	/* Step 3: Mark all memory below `freemem` as used (set `pp_ref` to 1) */
	u_long usedpage = PPN(PADDR(freemem));

	for (u_long i = 0; i < usedpage; i++) {
		pages[i].pp_ref = 1;
	}

	/* Step 4: Mark the other memory as free. */
	for (u_long i = usedpage; i < npage; i++) {
		pages[i].pp_ref = 0;
		LIST_INSERT_HEAD(&page_free_list, &pages[i], pp_link);
	}
}
```

* é¦–å…ˆæ˜¯åˆå§‹åŒ–ç©ºé—²ç‰©ç†å—æ•°ç»„ `page_free_list`ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`page_free_list`ç»è¿‡å±‚å±‚åŒ…è£…ï¼Œå¹¶ä¸æ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»å‹ï¼Œè€Œ `LIST_INIT`è¿™ä¸ªå®éœ€è¦ä½¿ç”¨ `->`æ¥è·å–åŸŸï¼Œå³éœ€è¦ä¼ å…¥æŒ‡é’ˆç±»å‹ï¼Œæ•…è¦åŠ ä¸Šå–å€ç¬¦å· `&`ã€‚
* ç„¶åå’Œåœ¨ `alloc`å‡½æ•°ä¸­ä¸€æ ·ï¼Œå¯¹å¯ç”¨ç©ºé—´èµ·å§‹ä½ç½® `freedom`æŒ‰ `PAGE_SIZE`å¯¹é½ã€‚
* éšåè·å– `freedom`åœ°å€å¯¹åº”çš„é¡µå·ï¼Œå°†è¿™ä¸ªé¡µå·ä¹‹å‰çš„é¡µéƒ½æ ‡è®°ä¸ºå·²ç»ä½¿ç”¨ï¼Œå³ `pp_ref`ç½®1ã€‚
* æœ€åæŠŠå‰©ä¸‹çš„é¡µè®¾ç½®ä¸ºæœªä½¿ç”¨ï¼Œå³ `pp_ref`ç½®0ï¼Œå¹¶æ’å…¥åˆ° `page_free_list`æ•°ç»„ä¸­ã€‚

åœ¨æœ‰äº†ä¸Šé¢å…¨éƒ¨çš„é¢„å¤‡çŸ¥è¯†ä¹‹åï¼Œè¿™é“é¢˜ä¾¿å¯ä»¥è¿åˆƒè€Œè§£äº†ï¼Œåªéœ€è¦æ³¨æ„å„ä¸ªå‡½æ•°ä»¥åŠå®çš„ä¼ å‚è§„èŒƒã€‚

---

### æ¥ä¸‹æ¥æ˜¯page_alloc()å‡½æ•°ï¼Œç»§ç»­ä¸Šä»£ç ï¼š

```c
int page_alloc(struct Page **new) {
	/* Step 1: Get a page from free memory. If fails, return the error code.*/
	struct Page *pp;

	if(LIST_EMPTY(&page_free_list)) {
		return -E_NO_MEM;
	}
	pp=LIST_FIRST(&page_free_list);

	LIST_REMOVE(pp, pp_link);

	// Step 2: Initialize this page with zero.
	memset((void *)(page2kva(pp)), 0, sizeof(struct Page));

	*new = pp;
	return 0;
}
```

* é¦–å…ˆæŸ¥çœ‹ç©ºé—²é¡µåˆ—è¡¨æ˜¯å¦ä¸ºç©º
* è‹¥éç©ºåˆ™ç”¨ `pp`å–é“¾è¡¨ç¬¬ä¸€é¡¹
* å†åˆ©ç”¨ `LIST_REMOVE`å®æŠŠè¿™ä¸€é¡¹ä»é“¾è¡¨ä»ç§»é™¤
* æœ€åç”¨ `memset`å°†è¿™æ®µåœ°å€ç½®0

æ¥ä¸‹æ¥æ˜¯ç”¨åˆ°çš„è¿™å‡ ä¸ªå®å’Œå‡½æ•°

```c
#define LIST_FIRST(head) ((head)->lh_first)

#define LIST_EMPTY(head) ((head)->lh_first == NULL)

#define LIST_REMOVE(elm, field)                                                                    \
	do {                                                                                       \
		if (LIST_NEXT((elm), field) != NULL)                                               \
			LIST_NEXT((elm), field)->field.le_prev = (elm)->field.le_prev;             \
		*(elm)->field.le_prev = LIST_NEXT((elm), field);                                   \
	} while (0)

void *memset(void *dst, int c, size_t n) {
	void *dstaddr = dst;
	void *max = dst + n;
	u_char byte = c & 0xff;
	uint32_t word = byte | byte << 8 | byte << 16 | byte << 24;

	while (((u_long)dst & 3) && dst < max) {
		*(u_char *)dst++ = byte;
	}

	// fill machine words while possible
	while (dst + 4 <= max) {
		*(uint32_t *)dst = word;
		dst += 4;
	}

	// finish the remaining 0-3 bytes
	while (dst < max) {
		*(u_char *)dst++ = byte;
	}
	return dstaddr;
}
```

å‰ä¸¤ä¸ªå…¶å®å°±æ˜¯å–ä¼ å…¥ç»“æ„ä½“æŒ‡é’ˆçš„lh_firståŸŸå¹¶æ£€æŸ¥å…¶æ˜¯å¦ä¸ºç©ºã€‚
`LIST_REMOVE`è¿˜æ˜¯ç”¨åŒå‘é“¾è¡¨é‚£ä¸€å¥—é€»è¾‘ã€‚
`memset`è¦æ³¨æ„çš„æ˜¯ä¼ å…¥ `void*`ç±»å‹å‚æ•°ã€‚

---

### page_free

ä¹‹åæ˜¯ `page_decref(struct Page *pp)`å‡½æ•°å’Œ `page_free(struct Page *pp)`å‡½æ•°ï¼Œå…¶ä¸­
`page_free`å‡½æ•°éœ€è¦æˆ‘ä»¬å¡«å†™ï¼Œå…¶ä½œç”¨æ˜¯å°† `pp` æŒ‡å‘çš„é¡µæ§åˆ¶å—é‡æ–°æ’å…¥åˆ° `page_free_list`ä¸­ã€‚
æ­¤å¤–éœ€è¦å…ˆç¡®ä¿ `pp` æŒ‡å‘çš„é¡µæ§åˆ¶å—å¯¹åº”çš„ç‰©ç†é¡µé¢å¼•ç”¨æ¬¡æ•°ä¸º0ã€‚

ä¸Šä»£ç ï¼š

```c
void page_free(struct Page *pp) {
	assert(pp->pp_ref == 0);
	/* Just insert it into 'page_free_list'. */
	/* Exercise 2.5: Your code here. */
	pp->pp_ref=0;
	LIST_INSERT_HEAD(&page_free_list, pp, pp_link);

}
```

ç¬¬ä¸€å¥ç±»ä¼¼äºæ—¥å¿—è¾“å‡ºï¼Œä¹‹åå°† `pp->ref`ç½®0ï¼Œå¹¶æ’å…¥ç©ºé—²é“¾è¡¨å¤´éƒ¨ï¼ˆ`LIST_INSERT_HEAD`ï¼‰ã€‚

---

### éšåæ¥åˆ°äº†è™šæ‹Ÿå†…å­˜ç®¡ç†â€”â€”ä¸¤çº§é¡µè¡¨

ä¸¤çº§é¡µè¡¨å³é¡µç›®å½•ï¼ˆPDï¼‰å’Œé¡µè¡¨ï¼ˆPTï¼‰ï¼Œä»–ä»¬çš„é¡µè¡¨é¡¹éƒ½æœ‰è‡ªå·±çš„ç±»å‹

```c
typedef u_long Pde;
typedef u_long Pte;
```

å…¶å®ä»–ä»¬çš„é¡µè¡¨é¡¹å°±æ˜¯ä¸€ä¸ª32ä½çš„æ•°ã€‚

#### æ¥ä¸‹æ¥æ˜¯ä¸¤çº§é¡µè¡¨æ“ä½œçš„ç¬¬ä¸€ä¸ªå‡½æ•° `pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)`

ä¸Šä»£ç ï¼š

```c
static int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte) {
	Pde *pgdir_entryp;
	struct Page *pp;

	/* Step 1: Get the corresponding page directory entry. */
	pgdir_entryp=pgdir+PDX(va);
	/* Step 2: If the corresponding page table is not existent (valid) then:
	 *   * If parameter `create` is set, create one. Set the permission bits 'PTE_C_CACHEABLE |
	 *     PTE_V' for this new page in the page directory. If failed to allocate a new page (out
	 *     of memory), return the error.
	 *   * Otherwise, assign NULL to '*ppte' and return 0.
	 */
	if(!(*pgdir_entryp&PTE_V)){
		if(create) {
			if(page_alloc(&pp)!=0) {
				return -E_NO_MEM;
			}
			pp->pp_ref++;
			*pgdir_entryp = page2pa(pp) | PTE_C_CACHEABLE | PTE_V;
			Pte *pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));
			*ppte = pgtable + PTX(va);
			return 0;
		}
		*ppte = NULL;
		return 0;
	}

	/* Step 3: Assign the kernel virtual address of the page table entry to '*ppte'. */
	/* Exercise 2.6: Your code here. (3/3) */
	Pte *pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));
	*ppte = pgtable + PTX(va);
	return 0;
}
```

ä¸ªäººè§‰å¾—è¿™ä¸ªå‡½æ•°æ¯”è¾ƒéš¾ç†è§£ï¼ˆğŸ˜­ï¼‰

é¦–å…ˆå®šä¹‰ä¸€ä¸ªä¸´æ—¶é¡µç›®å½•é¡¹æŒ‡é’ˆå’Œé¡µæŒ‡é’ˆï¼Œä¹‹åé€šè¿‡å–è™šæ‹Ÿåœ°å€ `va`çš„é«˜åä½ï¼Œæ¥æ‰¾åˆ°å®ƒå¯¹åº”é¡µç›®å½•é‡Œé¢çš„ç¬¬å‡ ä¸ªé¡µç›®å½•é¡¹ï¼Œ

ä¹‹åç”¨é¡µç›®å½•èµ·å§‹åœ°å€ `pgdir`æ¥åŠ ä¸Šè¿™ä¸ªåç§»å³å¾—åˆ°äº† `va`å¯¹åº”çš„é¡µç›®å½•é¡¹çš„åœ°å€ `pgdir_entryp`ï¼Œç”±äºé¡µç›®å½•ä¸€å®šå­˜åœ¨ï¼Œè€Œè¿™ä¸ªé¡µç›®å½•é¡¹å¯¹åº”çš„é¡µè¡¨ä¸ä¸€å®šå­˜åœ¨ï¼Œæ‰€ä»¥æ­¤æ—¶åˆ¤æ–­ `*pgdir_entryp`çš„æœ‰æ•ˆä½å³è¯¥å€¼ï¼ˆå¯¹åº”é¡µè¡¨ç‰©ç†åœ°å€ï¼‰çš„æœ‰æ•ˆæ€§ï¼Œå¦‚æœå¹¶éæœ‰æ•ˆï¼Œè€Œä¸”éœ€è¦åˆ›å»ºï¼Œé‚£ä¹ˆå°±é€šè¿‡ä¹‹å‰æ‰€å†™çš„ `page_alloc`å‡½æ•°å¯¹ `pp`è¿™ä¸ªé¡µæŒ‡é’ˆè¿›è¡Œåˆ†é…ï¼Œé‚£ä¹ˆå°±å¯ä»¥å¾—åˆ° `pp`ï¼Œå³æ‰€åˆ†é…çš„é¡µè¡¨å¯¹åº”é¡µï¼ˆåˆ«å¿˜äº†é¡µè¡¨å¤§å°æ°å¥½æ˜¯ä¸€ä¸ªé¡µï¼‰ã€‚

éšåï¼Œå°†åˆšæ‰é¡µç›®å½•ä¸­çš„é‚£ä¸ªé¡µç›®å½•é¡¹çš„å€¼åˆ†é…ä¸º `pp`é€šè¿‡ `page2pa`å‡½æ•°æ‰€è½¬åŒ–å‡ºæ¥çš„ç‰©ç†åœ°å€ï¼Œå¹¶è®¾ç½®æœ‰æ•ˆä½å’Œæƒé™ä½ï¼Œ
é‚£ä¹ˆæ­¤æ—¶å®šä¹‰ä¸€ä¸ªé¡µè¡¨é¡¹æŒ‡é’ˆä½œä¸ºåˆ†é…å‡ºæ¥é¡µè¡¨çš„ç¬¬ä¸€é¡¹æŒ‡é’ˆ `pgtable`ï¼ˆå› ä¸ºæ˜¯ç¬¬ä¸€é¡¹ï¼Œå…¶å® `pgtable`çš„å€¼ä¹Ÿå°±æ˜¯è¿™ä¸ªé¡µè¡¨çš„èµ·å§‹ç‰©ç†åœ°å€ï¼‰ï¼Œ
ç”¨ `pgtable`å»æ¥æ”¶ `*pgdir_entryp`çš„å€¼çš„å‰äºŒåä½ï¼ˆ`PTE_ADDR`å‡½æ•°ï¼‰ï¼Œç”±äºæˆ‘ä»¬æ˜¯åœ¨å†…æ ¸æ€ä¸‹è¿›è¡Œæ“ä½œçš„ï¼Œæ‰€ä»¥è¿˜éœ€è¦å°†ç‰©ç†åœ°å€è½¬åŒ–ä¸ºå†…æ ¸æ€è™šæ‹Ÿåœ°å€ï¼ˆ`KADDR`å‡½æ•°ï¼‰ï¼Œæœ€åå°† `va`å¯¹åº”çš„é¡µç›®å½•åç§»ä¸ `pgtable`ç›¸åŠ ï¼Œå°±å¾—åˆ°äº†åœ¨æ–°åˆ†é…çš„é¡µè¡¨ä¸­ `va`æŒ‡å‘çš„é¡µè¡¨é¡¹çš„åœ°å€ï¼Œå°†è¿™ä¸ªå€¼èµ‹ç»™ `*ppte`å³å¯ã€‚
åƒä¸‡åˆ«å¿˜äº†æŠŠ `pp_ref`åŠ ä¸€ï¼Œå½“ç„¶åœ¨æŒ‡å¯¼ä¹¦é‡Œä¹Ÿæœ‰è¿™ä¸ªæç¤ºã€‚

å¦‚æœé¡µè¡¨æœ‰æ•ˆï¼Œç›´æ¥èµ‹å€¼å³å¯ã€‚

---

#### æ¥ä¸‹æ¥æ˜¯å¢åŠ åœ°å€æ˜ å°„å‡½æ•°page_insert

ä¸Šä»£ç ï¼š

```c
int page_insert(Pde *pgdir, u_int asid, struct Page *pp, u_long va, u_int perm) {
	Pte *pte;

	/* Step 1: Get corresponding page table entry. */
	pgdir_walk(pgdir, va, 0, &pte);

	if (pte && (*pte & PTE_V)) {
		if (pa2page(*pte) != pp) {
			page_remove(pgdir, asid, va);
		} else {
			tlb_invalidate(asid, va);
			*pte = page2pa(pp) | perm | PTE_C_CACHEABLE | PTE_V;
			return 0;
		}
	}

	/* Step 2: Flush TLB with 'tlb_invalidate'. */
	tlb_invalidate(asid, va);

	/* Step 3: Re-get or create the page table entry. */
	/* If failed to create, return the error. */
	if (pgdir_walk(pgdir, va, 1, &pte)) {
		return -E_NO_MEM;
	}

	/* Step 4: Insert the page to the page table entry with 'perm | PTE_C_CACHEABLE | PTE_V'
	 * and increase its 'pp_ref'. */
	*pte = page2pa(pp) | perm | PTE_C_CACHEABLE | PTE_V;
	pp->pp_ref++;

	return 0;
}
```

è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯ä½œç”¨æ˜¯å°†ä¸€çº§é¡µè¡¨åŸºåœ°å€ `pgdir` å¯¹åº”çš„ä¸¤çº§é¡µè¡¨ç»“æ„ä¸­è™šæ‹Ÿåœ°å€ `va` æ˜ å°„åˆ°é¡µæ§åˆ¶å— `pp` å¯¹åº”çš„ç‰©ç†é¡µé¢ï¼Œå¹¶å°†é¡µè¡¨é¡¹æƒé™ä¸ºè®¾ç½®ä¸º `perm`ã€‚

é¦–å…ˆåˆ©ç”¨ `pgdir_walk`å‡½æ•°å°† `pte`çš„å€¼è®¾ç½®ä¸º `va`å¯¹åº”çš„äºŒçº§é¡µè¡¨é¡¹åœ°å€ï¼Œé‚£ä¹ˆ `*pte`çš„å€¼è‡ªç„¶å°±æ˜¯ `va`å¯¹åº”çš„ç‰©ç†åœ°å€ã€‚

å¦‚æœ `va`æœ‰å¯¹åº”çš„äºŒçº§é¡µè¡¨é¡¹æ˜ å°„ï¼Œå³ `pte`éç©ºä¸” `*pte`æœ‰æ•ˆï¼Œåˆ™æ£€æŸ¥ `*pte`ç‰©ç†åœ°å€å¯¹åº”çš„ç‰©ç†é¡µæ˜¯å¦æ˜¯ `pp`ï¼Œè‹¥ä¸åŒåˆ™ç§»é™¤è¯¥ç‰©ç†é¡µä¸ `va`çš„æ˜ å°„ï¼Œè‹¥ç›¸åŒåˆ™åˆ·æ–° `TLB`ï¼Œå¹¶å°† `pte`ä½ç½®çš„é¡µè¡¨é¡¹è®¾ç½®è¦æ±‚çš„æƒé™ã€‚

å¦‚æœ `va`æ²¡æœ‰å¯¹åº”çš„äºŒçº§é¡µè¡¨é¡¹æ˜ å°„ï¼Œåˆ™åˆ›å»ºè¯¥æ˜ å°„ï¼ˆåˆ›å»ºå¤±è´¥ç›´æ¥è¿”å›é”™è¯¯å€¼ï¼‰ï¼Œå¹¶è®¾ç½®æƒé™ã€‚

---

### æ¥ä¸‹æ¥æ˜¯è®¿é—®å†…å­˜ä¸TLBé‡å¡«

#### é¦–å…ˆæ˜¯ `TLB`æ—§è¡¨é¡¹æ— æ•ˆåŒ–å‡½æ•° `tlb_out`

```c
void tlb_invalidate(u_int asid, u_long va) {
	tlb_out((va & ~GENMASK(PGSHIFT, 0)) | (asid & (NASID - 1)));
}
```

ç”±è¿™ä¸ª `tlbex.c`ä¸­çš„å‡½æ•°ï¼Œè°ƒç”¨ `tlb_out`å‡½æ•°

```
LEAF(tlb_out)
.set noreorder
	mfc0    t0, CP0_ENTRYHI
	mtc0    a0, CP0_ENTRYHI
	nop
	/* Step 1: Use 'tlbp' to probe TLB entry */
	/* Exercise 2.8: Your code here. (1/2) */
	tlbp

	nop
	/* Step 2: Fetch the probe result from CP0.Index */
	mfc0    t1, CP0_INDEX
.set reorder
	bltz    t1, NO_SUCH_ENTRY
.set noreorder
	mtc0    zero, CP0_ENTRYHI
	mtc0    zero, CP0_ENTRYLO0
	mtc0    zero, CP0_ENTRYLO1
	nop
	/* Step 3: Use 'tlbwi' to write CP0.EntryHi/Lo into TLB at CP0.Index  */
	/* Exercise 2.8: Your code here. (2/2) */
	tlbwi

.set reorder

NO_SUCH_ENTRY:
	mtc0    t0, CP0_ENTRYHI
	j       ra
END(tlb_out)
```

å½“ `tlb_out` è¢« `tlb_invalidate` è°ƒç”¨æ—¶, `a0` å¯„å­˜å™¨ä¸­å­˜æ”¾ç€ä¼ å…¥çš„å‚æ•°ï¼Œå…¶å€¼ä¸ºæ—§è¡¨é¡¹çš„ `Key`ï¼ˆç”±è™šæ‹Ÿé¡µå·å’Œ `ASID` ç»„æˆï¼‰ã€‚æˆ‘ä»¬ä½¿ç”¨ `mtc0` æŒ‡ä»¤å°† `Key` å†™å…¥ `EntryHi`ï¼Œéšåä½¿ç”¨ `tlbp` æŒ‡ä»¤ï¼Œæ ¹æ® `EntryHi` ä¸­çš„ `Key` æŸ¥æ‰¾å¯¹åº”çš„æ—§è¡¨é¡¹ï¼Œå°†è¡¨é¡¹çš„ç´¢å¼•å­˜å…¥ `Index`ã€‚å¦‚æœç´¢å¼•å€¼å¤§äºç­‰äº0ï¼ˆå³ `TLB` ä¸­å­˜åœ¨ `Key` å¯¹åº”çš„è¡¨é¡¹ï¼‰ï¼Œæˆ‘ä»¬å‘ `EntryHi` å’Œ `EntryLo0`ã€`EntryLo1` ä¸­å†™å…¥0, éšåä½¿ç”¨ `tlbwi` æŒ‡ä»¤ï¼Œå°† `EntryHi` å’Œ `EntryLo0`ã€`EntryLo1` ä¸­çš„å€¼å†™å…¥ç´¢å¼•æŒ‡å®šçš„è¡¨é¡¹ã€‚æ­¤æ—¶æ—§è¡¨é¡¹çš„ `Key` å’Œ `Data`è¢«æ¸…é›¶ï¼Œå®ç°å°†å…¶æ— æ•ˆåŒ–ã€‚

---

#### æ¥ä¸‹æ¥æ˜¯TLBé‡å¡«

`tlbex.c`ä¸­ä»£ç 

```c
void _do_tlb_refill(u_long *pentrylo, u_int va, u_int asid) {
	tlb_invalidate(asid, va);
	Pte *ppte;
	/* Hints:
	 *  Invoke 'page_lookup' repeatedly in a loop to find the page table entry '*ppte'
	 * associated with the virtual address 'va' in the current address space 'cur_pgdir'.
	 *
	 *  **While** 'page_lookup' returns 'NULL', indicating that the '*ppte' could not be found,
	 *  allocate a new page using 'passive_alloc' until 'page_lookup' succeeds.
	 */

	/* Exercise 2.9: Your code here. */
	struct Page *p;
	while ((p = page_lookup(cur_pgdir, va, &ppte)) == NULL) {
    	passive_alloc(va, cur_pgdir, asid);
	}

	ppte = (Pte *)((u_long)ppte & ~0x7);
	pentrylo[0] = ppte[0] >> 6;
	pentrylo[1] = ppte[1] >> 6;

}
```

å…¶ä¸­TODOéƒ¨åˆ†çš„æç¤ºï¼šå°è¯•åœ¨å¾ªç¯ä¸­è°ƒç”¨ `page_lookup`ä»¥æŸ¥æ‰¾è™šæ‹Ÿåœ°å€ `va` åœ¨å½“å‰è¿›ç¨‹é¡µè¡¨ä¸­å¯¹åº”çš„é¡µè¡¨é¡¹ `*ppte`å¦‚æœ `page_lookup`å› `NULL`ï¼Œè¡¨æ˜ `*ppte`æ‰¾ä¸åˆ°ï¼Œä½¿ç”¨ `passive_alloc`ä¸º `va` æ‰€åœ¨çš„è™šæ‹Ÿé¡µé¢åˆ†é…ç‰©ç†é¡µé¢ï¼Œç›´è‡³ `page_lookup`è¿”å›ä¸ä¸º `NULL`åˆ™é€€å‡ºå¾ªç¯ã€‚ä½ å¯ä»¥åœ¨è°ƒç”¨å‡½æ•°æ—¶ï¼Œä½¿ç”¨å…¨å±€å˜é‡ `cur_pgdir` ä½œä¸ºå…¶ä¸­ä¸€ä¸ªå®å‚ã€‚

éœ€è¦è¡¥å…¨çš„ä»£ç æŒ‰æç¤ºå†™å³å¯ï¼Œå‡½æ•°æœ€åå°† `TLB`å¥‡å¶é¡µå‡ç”¨å¯¹åº”çš„äºŒçº§é¡µè¡¨é¡¹å³ç§»6ä½åå¡«å†™

ä¸‹é¢å¯¹è°ƒç”¨çš„å‡½æ•°è¿›è¡Œè§£é‡Š

* è¿™é‡Œçš„ `page_lookup`å‡½æ•°ï¼š

```c
struct Page *page_lookup(Pde *pgdir, u_long va, Pte **ppte) {
	struct Page *pp;
	Pte *pte;

	/* Step 1: Get the page table entry. */
	pgdir_walk(pgdir, va, 0, &pte);

	/* Hint: Check if the page table entry doesn't exist or is not valid. */
	if (pte == NULL || (*pte & PTE_V) == 0) {
		return NULL;
	}

	/* Step 2: Get the corresponding Page struct. */
	/* Hint: Use function `pa2page`, defined in include/pmap.h . */
	pp = pa2page(*pte);
	if (ppte) {
		*ppte = pte;
	}

	return pp;
}
```

å…¶ä½œç”¨å°±æ˜¯æ‰¾åˆ°è™šæ‹Ÿåœ°å€ `va`å¯¹åº”çš„ç‰©ç†é¡µå¹¶è¿”å›ã€‚

* è¿™é‡Œçš„passive_allocå‡½æ•°ï¼š

```c
static void passive_alloc(u_int va, Pde *pgdir, u_int asid) {
	struct Page *p = NULL;

	if (va < UTEMP) {
		panic("address too low");
	}

	if (va >= USTACKTOP && va < USTACKTOP + PAGE_SIZE) {
		panic("invalid memory");
	}

	if (va >= UENVS && va < UPAGES) {
		panic("envs zone");
	}

	if (va >= UPAGES && va < UVPT) {
		panic("pages zone");
	}

	if (va >= ULIM) {
		panic("kernel address");
	}

	panic_on(page_alloc(&p));
	panic_on(page_insert(pgdir, asid, p, PTE_ADDR(va), (va >= UVPT && va < ULIM) ? 0 : PTE_D));
}
```

å®é™…ä¸Šå°±æ˜¯ç»™vaè¿™ä¸ªè™šæ‹Ÿåœ°å€åˆ†é…äº†ä¸€ä¸ªç‰©ç†é¡µï¼Œå¹¶ç¡®å®šå…¶é¡µè¡¨é¡¹ã€‚

---

`tlbex.S`ä¸­ä»£ç 

```
NESTED(do_tlb_refill, 24, zero)
	mfc0    a1, CP0_BADVADDR
	mfc0    a2, CP0_ENTRYHI
	andi    a2, a2, 0xff /* ASID is stored in the lower 8 bits of CP0_ENTRYHI */
.globl do_tlb_refill_call;
do_tlb_refill_call:
	addi    sp, sp, -24 /* Allocate stack for arguments(3), return value(2), and return address(1) */
	sw      ra, 20(sp) /* [sp + 20] - [sp + 23] store the return address */
	addi    a0, sp, 12 /* [sp + 12] - [sp + 19] store the return value */
	jal     _do_tlb_refill /* (Pte *, u_int, u_int) [sp + 0] - [sp + 11] reserved for 3 args */
	lw      a0, 12(sp) /* Return value 0 - Even page table entry */
	lw      a1, 16(sp) /* Return value 1 - Odd page table entry */
	lw      ra, 20(sp) /* Return address */
	addi    sp, sp, 24 /* Deallocate stack */
	mtc0    a0, CP0_ENTRYLO0 /* Even page table entry */
	mtc0    a1, CP0_ENTRYLO1 /* Odd page table entry */
	nop
	/* Hint: use 'tlbwr' to write CP0.EntryHi/Lo into a random tlb entry. */
	/* Exercise 2.10: Your code here. */
	tlbwr

	jr      ra
END(do_tlb_refill)

```

è¿™é‡Œç›´æ¥ç™½ç»™äº†ï¼Œæ³¨é‡Šå§ç­”æ¡ˆç»™å‡ºæ¥äº†ã€‚

ä¸‹é¢å›é¡¾ä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹ï¼š

* ä» `BadVAddr` ä¸­å–å‡ºå¼•å‘ `TLB` ç¼ºå¤±çš„è™šæ‹Ÿåœ°å€ã€‚
* ä» `EntryHi` çš„0 â€“ 7 ä½å–å‡ºå½“å‰è¿›ç¨‹çš„ `ASID`ã€‚åœ¨Lab3 çš„ä»£ç ä¸­ï¼Œä¼šåœ¨è¿›ç¨‹åˆ‡æ¢æ—¶ä¿®æ”¹ `EntryHi` ä¸­çš„ `ASID`ï¼Œä»¥æ ‡è¯†è®¿å­˜æ‰€åœ¨çš„åœ°å€ç©ºé—´ã€‚
* å…ˆåœ¨æ ˆä¸Šä¸ºè¿”å›åœ°å€ã€å¾…å¡«å…¥ `TLB` çš„é¡µè¡¨é¡¹ä»¥åŠå‡½æ•°å‚æ•°ä¼ é€’é¢„ç•™ç©ºé—´ï¼Œå¹¶å­˜å…¥è¿”å›åœ°å€ã€‚ä»¥å­˜å‚¨å¥‡å¶é¡µè¡¨é¡¹çš„åœ°å€ã€è§¦å‘å¼‚å¸¸çš„è™šæ‹Ÿåœ°å€å’Œ `ASID` ä¸ºå‚æ•°ï¼Œè°ƒç”¨ `_do_tlb_refill`å‡½æ•°ã€‚è¯¥å‡½æ•°æ˜¯ `TLB` é‡å¡«è¿‡ç¨‹çš„æ ¸å¿ƒï¼Œå…¶åŠŸèƒ½æ˜¯æ ¹æ®è™šæ‹Ÿåœ°å€å’Œ `ASID` æŸ¥æ‰¾é¡µè¡¨ï¼Œå°†å¯¹åº”çš„å¥‡å¶é¡µè¡¨é¡¹å†™å›å…¶ç¬¬ä¸€ä¸ªå‚æ•°æ‰€æŒ‡å®šçš„åœ°å€ã€‚
* å°†é¡µè¡¨é¡¹å­˜å…¥ `EntryLo0`ã€`EntryLo1` ï¼Œå¹¶æ‰§è¡Œ `tlbwr` å°†æ­¤æ—¶çš„ `EntryHi` ä¸ `EntryLo0`ã€`EntryLo1` å†™å…¥åˆ° `TLB` ä¸­ï¼ˆåœ¨å‘ç”Ÿ `TLB` ç¼ºå¤±æ—¶ï¼Œ`EntryHi` å·²ç»ç”±ç¡¬ä»¶å†™å…¥äº†è™šæ‹Ÿé¡µå·ç­‰ä¿¡æ¯ï¼Œæ— éœ€ä¿®æ”¹ï¼‰ã€‚

---

---

## æ€è€ƒé¢˜

### 2.1

* é¢˜ç›®ï¼š

```
è¯·æ ¹æ®ä¸Šè¿°è¯´æ˜ï¼Œå›ç­”é—®é¢˜ï¼šåœ¨ç¼–å†™çš„C ç¨‹åºä¸­ï¼ŒæŒ‡é’ˆå˜é‡ä¸­å­˜å‚¨çš„åœ°å€è¢«è§†ä¸ºè™šæ‹Ÿåœ°å€ï¼Œè¿˜æ˜¯ç‰©ç†åœ°å€ï¼ŸMIPS æ±‡ç¼–ç¨‹åºä¸­ lw å’Œsw æŒ‡ä»¤ä½¿ç”¨çš„åœ°å€è¢«è§†ä¸ºè™šæ‹Ÿåœ°å€ï¼Œè¿˜æ˜¯ç‰©ç†åœ°å€ï¼Ÿ
```

* ç­”æ¡ˆï¼š

```
å‡è¢«è§†ä¸ºè™šæ‹Ÿåœ°å€
```

### 2.2

ç¬¬ä¸€é—®â€”â€”ä½¿ç”¨å®æ¥å®ç°é“¾è¡¨çš„ä¸€ä¸ªæ˜¾è‘—å¥½å¤„æ˜¯**æé«˜äº†ä»£ç çš„å¯é‡ç”¨æ€§**ã€‚è¿™æœ‰å‡ ä¸ªæ–¹é¢ï¼š

#### 1.æŠ½è±¡æ€§ï¼š

* å®èƒ½å¤ŸæŠŠé“¾è¡¨çš„æ“ä½œå°è£…èµ·æ¥ï¼Œå¦‚æ’å…¥ã€åˆ é™¤ã€éå†ç­‰ï¼Œæä¾›ç»Ÿä¸€çš„æ¥å£ï¼Œè€Œä¸å…³å¿ƒé“¾è¡¨çš„å…·ä½“å®ç°ç»†èŠ‚ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œæˆ‘ä»¬ä¸éœ€è¦é‡å¤å†™ç›¸åŒçš„é“¾è¡¨æ“ä½œä»£ç ï¼Œé¿å…äº†å†—ä½™çš„ä»£ç ç¼–å†™ã€‚
* é“¾è¡¨çš„ç±»å‹å’Œç»“æ„ä¸å†å±€é™äºç‰¹å®šæ•°æ®ç»“æ„ï¼Œå®å¯ä»¥é€‚ç”¨äºä¸åŒç±»å‹çš„é“¾è¡¨ï¼ˆå•é“¾è¡¨ã€åŒé“¾è¡¨ç­‰ï¼‰ã€‚

#### 2.ä»£ç æ¨¡å—åŒ–ï¼š

* å®å°†é“¾è¡¨æ“ä½œä¸å…·ä½“å®ç°ç»†èŠ‚åˆ†å¼€ï¼Œä½¿å¾—åœ¨é“¾è¡¨æ“ä½œå‘ç”Ÿå˜åŒ–æ—¶ï¼Œåªéœ€è¦ä¿®æ”¹å®å®šä¹‰éƒ¨åˆ†ï¼Œè€Œä¸éœ€è¦ä¿®æ”¹é“¾è¡¨ä½¿ç”¨çš„å…¶ä»–åœ°æ–¹ã€‚è¿™ä¹Ÿä¿ƒè¿›äº†ä»£ç çš„æ¨¡å—åŒ–å’Œå¯ç»´æŠ¤æ€§ã€‚

#### 3.çµæ´»æ€§ï¼š

* å®é€šè¿‡å‚æ•°åŒ–ï¼Œæä¾›äº†çµæ´»çš„åŠŸèƒ½ï¼Œä¾‹å¦‚æ”¯æŒä¸åŒæ•°æ®ç±»å‹çš„é“¾è¡¨ã€ä¸åŒé“¾è¡¨çš„æ’å…¥ä½ç½®ï¼ˆå¤´éƒ¨ã€å°¾éƒ¨ã€ç‰¹å®šä½ç½®ï¼‰ï¼Œè¿™ä½¿å¾—é“¾è¡¨æ“ä½œå¯ä»¥é€‚åº”æ›´å¤šçš„ä½¿ç”¨åœºæ™¯ã€‚

#### 4.å‡å°‘é”™è¯¯ï¼š

* é€šè¿‡å®å®ç°é“¾è¡¨æ“ä½œï¼Œé¿å…äº†æ‰‹åŠ¨å®ç°çš„è¿‡ç¨‹ä¸­å®¹æ˜“å‡ºç°çš„é”™è¯¯ã€‚ä¾‹å¦‚ï¼Œæ‰‹åŠ¨å®ç°é“¾è¡¨æ“ä½œå¯èƒ½ä¼šæ¼æ‰æŸäº›æŒ‡é’ˆçš„æ›´æ–°ï¼Œå¯¼è‡´é“¾è¡¨ç ´è£‚ï¼Œè€Œé€šè¿‡å®æ¥å®ç°é“¾è¡¨æ“ä½œï¼Œé€šå¸¸ä¼šä½¿å¾—é“¾è¡¨çš„æ’å…¥ã€åˆ é™¤æ“ä½œæ›´åŠ ä¸€è‡´å’Œå¥å£®ã€‚

ç¬¬äºŒé—®â€”â€”æ¯”è¾ƒå•å‘é“¾è¡¨ã€å¾ªç¯é“¾è¡¨å’ŒåŒå‘é“¾è¡¨åœ¨æ’å…¥ä¸åˆ é™¤æ“ä½œä¸Šçš„æ€§èƒ½å·®å¼‚

* æ’å…¥æ€§èƒ½ï¼š

å•å‘é“¾è¡¨ï¼šåªèƒ½ä»å¤´éƒ¨å¿«é€Ÿæ’å…¥ï¼Œå°¾éƒ¨æ’å…¥éœ€è¦éå†ã€‚

å¾ªç¯é“¾è¡¨ï¼šä»å°¾éƒ¨æ’å…¥æ¯”å•å‘é“¾è¡¨æ›´é«˜æ•ˆï¼Œä½†åˆ é™¤æ“ä½œä»ç„¶éœ€è¦éå†ã€‚

åŒå‘é“¾è¡¨ï¼šæ— è®ºæ˜¯å¤´éƒ¨ã€å°¾éƒ¨è¿˜æ˜¯ä¸­é—´ï¼Œæ’å…¥å’Œåˆ é™¤éƒ½å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…å®Œæˆã€‚

* åˆ é™¤æ€§èƒ½ï¼š

å•å‘é“¾è¡¨å’Œå¾ªç¯é“¾è¡¨ï¼šåˆ é™¤ä¸­é—´èŠ‚ç‚¹æ—¶éœ€è¦éå†é“¾è¡¨ï¼Œæ•ˆç‡è¾ƒä½ã€‚

åŒå‘é“¾è¡¨ï¼šæ”¯æŒå¿«é€Ÿçš„åŒå‘è®¿é—®ï¼Œåˆ é™¤ä»»ä½•èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬ä¸­é—´èŠ‚ç‚¹ï¼‰éƒ½å¯ä»¥åœ¨ O(1) æ—¶é—´å†…å®Œæˆã€‚

* æ€»ç»“ï¼š

åŒå‘é“¾è¡¨ï¼šå¯¹äºé¢‘ç¹æ’å…¥å’Œåˆ é™¤æ“ä½œï¼Œå°¤å…¶æ˜¯åœ¨ä¸¤ç«¯æ“ä½œçš„åœºæ™¯ï¼ŒåŒå‘é“¾è¡¨è¡¨ç°æœ€å¥½ã€‚

å¾ªç¯é“¾è¡¨ï¼šé€‚åˆå¾ªç¯è®¿é—®çš„åœºæ™¯ï¼Œä½†æ’å…¥å’Œåˆ é™¤æ—¶ä»ç„¶å—åˆ°ä¸€å®šé™åˆ¶ã€‚

å•å‘é“¾è¡¨ï¼šåœ¨ç»“æ„ç®€å•ã€è®¿é—®æ¨¡å¼è¾ƒä¸ºå•ä¸€æ—¶æœ€ä¸ºé«˜æ•ˆã€‚

### 2.3

é—®é¢˜ï¼šè¯·é˜…è¯» `include/queue.h` ä»¥åŠ `include/pmap.h`, å°† `Page_list` çš„ç»“æ„æ¢³ç†æ¸…æ¥šï¼Œé€‰æ‹©æ­£ç¡®çš„å±•å¼€ç»“æ„ã€‚

ç­”æ¡ˆåº”è¯¥é€‰Cï¼Œ

å› ä¸ºé¦–å…ˆå†…å±‚ `Page`é‡Œé¢çš„ `le_prev`æ˜¯åŒæŒ‡é’ˆï¼Œå…¶æ¬¡å¤–å±‚åœ¨å®šä¹‰æ—¶å°±å·²ç»å†™äº† `struct type *lh_first;`ï¼Œæ•…åº”ä¸º

```c
struct Page_list{
	struct Page{
		struct {                                                                                   \
			struct type *le_next;  /* next element */                                  \
			struct type **le_prev; /* address of previous next element */              \
		} pp_link;
		u_short pp_ref;
	}* lh_first;
}
```

### 2.4

#### ASIDçš„å¿…è¦æ€§

åœ¨å¤šè¿›ç¨‹æ“ä½œç³»ç»Ÿä¸­ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªå·±çš„è™šæ‹Ÿå†…å­˜åœ°å€ç©ºé—´ã€‚ä¸ºäº†æœ‰æ•ˆç®¡ç†è™šæ‹Ÿå†…å­˜ï¼Œæ“ä½œç³»ç»Ÿé€šå¸¸ä½¿ç”¨TLBï¼ˆTranslation Lookaside Bufferï¼‰æ¥åŠ é€Ÿè™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢ã€‚ç”±äºTLBçš„ç¼“å­˜æ˜¯åŸºäºè™šæ‹Ÿåœ°å€çš„ï¼Œå› æ­¤åœ¨å¤šè¿›ç¨‹ç¯å¢ƒä¸‹ï¼Œä¸åŒè¿›ç¨‹å¯èƒ½ä¼šä½¿ç”¨ç›¸åŒçš„è™šæ‹Ÿåœ°å€ï¼Œè¿™å°±å¯èƒ½å¯¼è‡´ç¼“å­˜å†²çªï¼Œå½±å“ç³»ç»Ÿæ€§èƒ½ã€‚ä¸ºäº†é¿å…è¿™ç§é—®é¢˜ï¼Œæ“ä½œç³»ç»Ÿå¼•å…¥äº†ASIDï¼ˆAddress Space Identifierï¼‰ï¼Œå³åœ°å€ç©ºé—´æ ‡è¯†ç¬¦ã€‚

#### MIPS 4Kc ä¸­çš„ASIDæ®µä½æ•°å’Œæœ€å¤§åœ°å€ç©ºé—´æ•°é‡

MIPS 4Kcçš„ASIDä½¿ç”¨ 8ä½ æ¥æ ‡è¯†ã€‚è¿™æ ·ï¼ŒASIDå¯ä»¥è¡¨ç¤º 2^8 = 256 ä¸ªä¸åŒçš„åœ°å€ç©ºé—´ã€‚

æœ€å¤§åœ°å€ç©ºé—´æ•°é‡ï¼š

æ¯ä¸ªè¿›ç¨‹åœ¨TLBä¸­éƒ½æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„ASIDï¼Œé€šè¿‡è¿™ä¸ªASIDï¼Œ4Kcèƒ½å¤Ÿç®¡ç†æœ€å¤š 256ä¸ªä¸åŒçš„åœ°å€ç©ºé—´ã€‚è¿™æ„å‘³ç€æ“ä½œç³»ç»Ÿå¯ä»¥åœ¨åŒä¸€ç³»ç»Ÿä¸ŠåŒæ—¶è¿è¡Œå¤šè¾¾256ä¸ªè¿›ç¨‹ï¼Œæ¯ä¸ªè¿›ç¨‹æœ‰è‡ªå·±çš„è™šæ‹Ÿå†…å­˜åœ°å€ç©ºé—´ï¼Œäº’ä¸å¹²æ‰°ã€‚

æ€»ç»“ï¼š

åœ¨MIPS 4Kcä¸­ï¼ŒASIDæ®µå æ®8ä½ï¼Œå› æ­¤ç³»ç»Ÿå¯ä»¥æ”¯æŒæœ€å¤š 256ä¸ªä¸åŒçš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå³æœ€å¤šæ”¯æŒ256ä¸ªè¿›ç¨‹åŒæ—¶è¿è¡Œï¼Œè€Œä¸ä¼šå‡ºç°TLBå†²çªçš„é—®é¢˜ ã€‚

### 2.5

**1. tlb_invalidate å’Œ tlb_out çš„è°ƒç”¨å…³ç³»**

**tlb_invalidate** å‡½æ•°ç”¨äºæ— æ•ˆåŒ–æŒ‡å®šçš„ TLB æ¡ç›®ã€‚å®ƒé€šè¿‡è°ƒç”¨ **tlb_out** æ¥åˆ·æ–° TLB ä¸­çš„æ¡ç›®ã€‚åœ¨ **tlb_invalidate** ä¸­ï¼Œè™šæ‹Ÿåœ°å€å’Œ ASID è¢«ä¼ é€’åˆ° **tlb_out**ï¼Œä»è€Œåœ¨ **tlb_out** ä¸­æ‰§è¡Œ TLB æ— æ•ˆåŒ–æ“ä½œã€‚å…·ä½“æ¥è¯´ï¼Œ**tlb_invalidate** ä¼šè°ƒç”¨ **tlb_out** æ¥æ¸…é™¤å’Œåˆ·æ–° TLB ä¸­ä¸ç»™å®šè™šæ‹Ÿåœ°å€å’Œ ASID ç›¸å…³çš„æ¡ç›®ã€‚

**2. ä¸€å¥è¯æ¦‚æ‹¬ tlb_invalidate çš„ä½œç”¨**

**tlb_invalidate** çš„ä½œç”¨æ˜¯æ ¹æ®ç»™å®šçš„ ASID å’Œè™šæ‹Ÿåœ°å€æ¥æ— æ•ˆåŒ–ç›¸åº”çš„ TLB æ¡ç›®ã€‚

**3. é€è¡Œè§£é‡Š tlb_out ä¸­çš„æ±‡ç¼–ä»£ç **

```shell
LEAF(tlb_out)
.set noreorder
	mfc0    t0, CP0_ENTRYHI      # ä» CP0 çš„ ENTRYHI å¯„å­˜å™¨è·å–å½“å‰çš„ ASIDï¼ˆåœ°å€ç©ºé—´æ ‡è¯†ç¬¦ï¼‰å¹¶å­˜å‚¨åˆ° t0 å¯„å­˜å™¨
	mtc0    a0, CP0_ENTRYHI      # å°† a0 å¯„å­˜å™¨çš„å€¼ï¼ˆæ–°çš„ ASIDï¼‰å†™å…¥åˆ° CP0 çš„ ENTRYHI å¯„å­˜å™¨
	nop                           # æ— æ“ä½œï¼ˆå¡«å……æŒ‡ä»¤ï¼Œç”¨äºå»¶è¿Ÿæ§½ï¼‰
	tlbp                           # æ‰§è¡Œ TLB æ¢æµ‹æŒ‡ä»¤ï¼Œæ£€æŸ¥è™šæ‹Ÿåœ°å€æ˜¯å¦å·²å­˜åœ¨äº TLB ä¸­
	nop                           # æ— æ“ä½œï¼ˆå¡«å……æŒ‡ä»¤ï¼Œç”¨äºå»¶è¿Ÿæ§½ï¼‰
	mfc0    t1, CP0_INDEX        # ä» CP0 çš„ INDEX å¯„å­˜å™¨è·å–å½“å‰ TLB å…¥å£çš„ç´¢å¼•
.set reorder
	bltz    t1, NO_SUCH_ENTRY    # å¦‚æœ t1 å¯„å­˜å™¨çš„å€¼å°äº 0ï¼Œè¡¨ç¤ºæœªå‘½ä¸­ TLB æ¡ç›®ï¼Œè·³è½¬åˆ° NO_SUCH_ENTRY æ ‡ç­¾
.set noreorder
	mtc0    zero, CP0_ENTRYHI    # å°† CP0 çš„ ENTRYHIã€ENTRYLO0ã€ENTRYLO1 å¯„å­˜å™¨æ¸…é›¶ï¼Œæ¸…é™¤ç›¸å…³çš„ TLB æ¡ç›®
	mtc0    zero, CP0_ENTRYLO0
	mtc0    zero, CP0_ENTRYLO1
	nop                           # æ— æ“ä½œï¼ˆå¡«å……æŒ‡ä»¤ï¼Œç”¨äºå»¶è¿Ÿæ§½ï¼‰
	tlbwi                          # å°† CP0 çš„ ENTRYHIã€ENTRYLO0 å’Œ ENTRYLO1 å†™å…¥åˆ° TLB ä¸­ï¼ˆå¦‚æœæ‰¾åˆ°äº†æ¡ç›®ï¼‰
.set reorder
NO_SUCH_ENTRY:
	mtc0    t0, CP0_ENTRYHI      # æ¢å¤ä¹‹å‰å­˜å‚¨çš„ ASID åˆ° CP0 çš„ ENTRYHI å¯„å­˜å™¨
	j       ra                    # è¿”å›è°ƒç”¨è€…
END(tlb_out)
```

### 2.6

æ¯æ¬¡å‡½æ•°è°ƒç”¨æ—¶ï¼ŒCPU ä¼šè®¿é—®æ ˆå†…å­˜ï¼Œåˆ†é…ç©ºé—´ä»¥ä¿å­˜å‚æ•°ã€å±€éƒ¨å˜é‡å’Œè¿”å›åœ°å€ï¼Œè¿™äº›å†…å­˜è®¿é—®éœ€è¦é€šè¿‡è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢ã€‚

åœ¨è®¿é—®è¿‡ç¨‹ä¸­ï¼ŒCPU ä¼šå…ˆæŸ¥æ‰¾ TLBä»¥åŠ é€Ÿåœ°å€è½¬æ¢ï¼›
è‹¥ TLB ä¸­æ²¡æœ‰ç›¸åº”çš„æ¡ç›®ï¼Œåˆ™ä¼šæŸ¥æ‰¾é¡µè¡¨ã€‚
å¦‚æœå‘ç”Ÿ TLB miss æˆ–é¡µè¡¨ç¼ºå¤±ï¼ŒCPU ä¼šè§¦å‘å¼‚å¸¸å¹¶æ‰§è¡Œå¼‚å¸¸å¤„ç†ç¨‹åºï¼Œæ›´æ–° TLB æˆ–é¡µè¡¨ã€‚

å‡½æ•°è¿”å›æ—¶ï¼Œæ ˆç©ºé—´ä¼šè¢«æ¢å¤ï¼Œç±»ä¼¼çš„å†…å­˜è®¿é—®ä¹Ÿä¾èµ–äºè™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢ã€‚

æ€»ä¹‹ï¼Œå‡½æ•°è°ƒç”¨è¿‡ç¨‹ä¸­çš„æ ˆæ“ä½œå’Œå†…å­˜è®¿é—®éœ€è¦ä¾èµ– TLB å’Œé¡µè¡¨çš„ååŒå·¥ä½œï¼Œç¡®ä¿è™šæ‹Ÿå†…å­˜èƒ½å¤Ÿæ­£ç¡®æ˜ å°„åˆ°ç‰©ç†å†…å­˜ã€‚

### 2.7

**RISC-V å†…å­˜ç®¡ç†æœºåˆ¶**

RISC-V æ˜¯ä¸€ç§ç²¾ç®€æŒ‡ä»¤é›†è®¡ç®—æœºï¼ˆRISCï¼‰æ¶æ„ï¼Œå…·æœ‰ç®€å•çš„è®¾è®¡ï¼Œå¹¶ä¸”æ”¯æŒå¤šç§å†…å­˜ç®¡ç†ç‰¹æ€§ã€‚RISC-V çš„å†…å­˜ç®¡ç†æœºåˆ¶ä¸»è¦ä¾èµ–äºè™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„æ˜ å°„ï¼Œä½¿ç”¨é¡µè¡¨å’Œ MMUï¼ˆå†…å­˜ç®¡ç†å•å…ƒï¼‰æ¥è¿›è¡Œåœ°å€è½¬æ¢ã€‚ä»¥ä¸‹æ˜¯ RISC-V å†…å­˜ç®¡ç†çš„ä¸€äº›å…³é”®ç‰¹æ€§ï¼š

**1.è™šæ‹Ÿå†…å­˜æ”¯æŒ** ï¼šRISC-V æ”¯æŒè™šæ‹Ÿå†…å­˜ï¼Œå…è®¸æ“ä½œç³»ç»Ÿä¸ºæ¯ä¸ªè¿›ç¨‹æä¾›ç‹¬ç«‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œè¿™ä½¿å¾—æ¯ä¸ªè¿›ç¨‹çš„å†…å­˜ç®¡ç†æ›´ä¸ºå®‰å…¨å’Œé«˜æ•ˆã€‚

**2.é¡µè¡¨** ï¼šRISC-V ä½¿ç”¨åˆ†é¡µæœºåˆ¶ï¼Œé‡‡ç”¨å¤šçº§é¡µè¡¨æ¥å°†è™šæ‹Ÿåœ°å€è½¬æ¢ä¸ºç‰©ç†åœ°å€ã€‚å…·ä½“å®ç°åŒ…æ‹¬é¡µè¡¨çš„åˆ†å±‚ç»“æ„ï¼Œä¾‹å¦‚ä¸‰çº§é¡µè¡¨ï¼ˆå¦‚æœä½¿ç”¨ 64 ä½è™šæ‹Ÿåœ°å€ï¼‰ã€‚é¡µè¡¨é¡¹å­˜å‚¨äº†è™šæ‹Ÿé¡µåˆ°ç‰©ç†é¡µçš„æ˜ å°„ä¿¡æ¯ã€‚

**3.TLB** ï¼šä¸ºäº†åŠ é€Ÿè™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢ï¼ŒRISC-V ä½¿ç”¨ TLBï¼Œç¼“å­˜æœ€è¿‘è®¿é—®çš„é¡µè¡¨é¡¹ã€‚TLB é€šè¿‡ç›´æ¥æ˜ å°„è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€æ¥æé«˜å†…å­˜è®¿é—®é€Ÿåº¦ã€‚

**4.è™šæ‹Ÿåœ°å€ç©ºé—´** ï¼šRISC-V æ”¯æŒç”¨æˆ·æ¨¡å¼å’Œå†…æ ¸æ¨¡å¼çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œç¡®ä¿å†…æ ¸ä¸ç”¨æˆ·ç¨‹åºçš„å†…å­˜éš”ç¦»ï¼Œæé«˜ç³»ç»Ÿçš„å®‰å…¨æ€§ã€‚

**5.å¼‚å¸¸å¤„ç†** ï¼šå½“å‘ç”Ÿé¡µé¢é”™è¯¯ï¼ˆå¦‚ç¼ºé¡µï¼‰æ—¶ï¼ŒRISC-V ä¼šè§¦å‘ä¸€ä¸ªå¼‚å¸¸ï¼Œæ“ä½œç³»ç»Ÿè´Ÿè´£å¤„ç†ç¼ºé¡µå¼‚å¸¸å¹¶æ›´æ–°é¡µè¡¨ï¼Œä»è€Œæ¢å¤æ­£å¸¸æ‰§è¡Œã€‚


**RISC-V ä¸ MIPS åœ¨å†…å­˜ç®¡ç†ä¸Šçš„åŒºåˆ«**

**1.é¡µè¡¨ç»“æ„** ï¼š

RISC-Vï¼šä½¿ç”¨æ›´çµæ´»çš„å¤šçº§é¡µè¡¨ç»“æ„ï¼Œæ”¯æŒæ›´å¤§çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼ˆå¦‚ 64 ä½ï¼‰ï¼Œå¹¶ä¸”å…·æœ‰æ›´é«˜çš„æ‰©å±•æ€§ã€‚

MIPSï¼šé€šå¸¸ä½¿ç”¨è¾ƒç®€å•çš„äºŒçº§é¡µè¡¨ï¼Œè¾ƒå°‘æ”¯æŒå¤§èŒƒå›´çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼ˆé€šå¸¸ä¸º 32 ä½ï¼‰ã€‚

**2.åœ°å€ç©ºé—´** ï¼š

RISC-Vï¼šæä¾›äº†æ›´çµæ´»çš„è™šæ‹Ÿåœ°å€ç©ºé—´è®¾è®¡ï¼Œæ”¯æŒ 32 ä½å’Œ 64 ä½åœ°å€ç©ºé—´ã€‚RISC-V é€šè¿‡å®šä¹‰ä¸åŒçš„æ¨¡å¼ï¼ˆå¦‚ Sæ¨¡å¼ã€Mæ¨¡å¼ç­‰ï¼‰æ¥æ”¯æŒç”¨æˆ·æ¨¡å¼å’Œå†…æ ¸æ¨¡å¼çš„å†…å­˜éš”ç¦»ã€‚

MIPSï¼šè¾ƒå¤šé‡‡ç”¨ 32 ä½åœ°å€ç©ºé—´ï¼Œæ”¯æŒç”¨æˆ·æ¨¡å¼å’Œå†…æ ¸æ¨¡å¼ï¼Œä½†é€šå¸¸ä¸å¦‚ RISC-V çµæ´»ã€‚

**3.è™šæ‹Ÿå†…å­˜ä¸å¼‚å¸¸å¤„ç†** ï¼š

RISC-Vï¼šæ›´æ³¨é‡æ‰©å±•æ€§ï¼Œæ”¯æŒæ›´å¤æ‚çš„è™šæ‹Ÿå†…å­˜æœºåˆ¶ï¼ˆå¦‚æ”¯æŒæ›´å¤šçº§åˆ«çš„é¡µè¡¨ï¼‰ï¼Œå¹¶é€šè¿‡æ›´ç»†ç²’åº¦çš„å¼‚å¸¸ç®¡ç†æ¥å¤„ç†è™šæ‹Ÿå†…å­˜å¼‚å¸¸ã€‚

MIPSï¼šè™šæ‹Ÿå†…å­˜å’Œå¼‚å¸¸å¤„ç†æœºåˆ¶è¾ƒä¸ºç®€å•ï¼Œä½†åŒæ ·èƒ½å¤Ÿé€šè¿‡é¡µè¡¨å’Œ TLB æä¾›å†…å­˜ç®¡ç†å’Œå¼‚å¸¸å¤„ç†ã€‚

**4.TLB è®¾è®¡** ï¼š

RISC-Vï¼šæ”¯æŒæ›´å¤æ‚çš„ TLB è®¾è®¡ï¼Œé€šå¸¸åŒ…æ‹¬å¤šçº§ TLBï¼Œå¹¶å…·æœ‰æ›´å¤§çš„çµæ´»æ€§ã€‚

MIPSï¼šTLB é€šå¸¸æ¯”è¾ƒç®€å•ï¼Œé€šå¸¸åªæœ‰ä¸€çº§ TLBï¼Œå®¹é‡è¾ƒå°ï¼Œè®¾è®¡ä¸Šè¾ƒä¸ºç®€åŒ–ã€‚
